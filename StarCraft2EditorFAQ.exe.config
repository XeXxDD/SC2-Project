<?xml version="1.0" encoding="utf-8"?>
<configuration>
    <configSections>
        <sectionGroup name="applicationSettings" type="System.Configuration.ApplicationSettingsGroup, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
            <section name="SC2MapEdtiorXeXxD.Properties.Settings" type="System.Configuration.ClientSettingsSection, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" requirePermission="false"/>
            <section name="SC2MapEdtiorXeX.Properties.Settings" type="System.Configuration.ClientSettingsSection, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" requirePermission="false"/>
        </sectionGroup>
        <sectionGroup name="userSettings" type="System.Configuration.UserSettingsGroup, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
            <section name="SC2MapEdtiorXeXxD.Properties.Settings" type="System.Configuration.ClientSettingsSection, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" allowExeDefinition="MachineToLocalUser" requirePermission="false"/>
        </sectionGroup>
    </configSections>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.8"/>
    </startup>
    <applicationSettings>
        <SC2MapEdtiorXeXxD.Properties.Settings>
            <setting name="Module2_Otvet0" serializeAs="String">
                <value>Создаем новый триггер (Рисунок 0)
В нем создаем событие Chat Message (Рисунок 1)
Создав его, мы видим параметры, которое может принимать это событие (Рисунок 2)
Далее, где Text: вписываете команду, на которую будет срабатывать триггер

Теперь создаем локальную переменную, называем ее Units (название может быть любым) и указываем ей тип "группа единиц" (Рисунок 3)
Создаем действие Set Varialbe (Рисунок 4)
Где Varible, указываем свою переменную Units (Рисунок 5)
Где Value, указываем: функция - Selected Units (Рисунок 6)
Где Player, указываем Triggering Player (Рисунок 7)

Далее создаем действие Pick Each Unit In Unit Group (Рисунок 8)
Где Unit Group, указываем нашу переменную Units (Рисунок 9)

Теперь тут же создаем действие If Then Else (Рисунок 10)
Где if создаем новый элемент (по умолчанию сравнение)(Ctrl + W) (Рисунок 11)
Где Value 1: Owner of Unit есть параметр Unit
В него указываем Picked Unit (Рисунок 12)
Где Value 2: Меняем на Triggering Player (Рисунок 13)
Далее в Then создаем действие Kill Unit (Рисунок 14)
Triggering Unit меняем на Picked Unit (Рисунок 15)</value>
            </setting>
            <setting name="Module3_Vopros0" serializeAs="String">
                <value>Начало работы с модуем данных</value>
            </setting>
            <setting name="Module3_Vopros1" serializeAs="String">
                <value>Как сделать чтобы за убийство давались ресурсы?</value>
            </setting>
            <setting name="Module3_Otvet1" serializeAs="String">
                <value>Открыв вкладку "Единицы" найдите там юнита, за убийство которого будут даваться ресурсы.
Найдите поле "Уничтожить ресурс+" и открыв его, вы можете указать до 4х разных ресурсов.
Указывайте нужно количество и жмите ок

//Надо будет передать этот ответ
//Как-то мне он не нравится)</value>
            </setting>
            <setting name="Module3_Otvet0" serializeAs="String">
                <value>Для начала работы с модулем данных, выставьте настройки таким образом (Рисунок 0)
Чтобы находить любые нужные данные, вы можете открывать и добавлять себе любые доступные вкладки (Рисунок 1)

Это нужно для того, чтобы при просмотре ответов на вопросы по модулю данных, у вас не возникали вопросы, с непониманием того, почему у меня что-то отображается, а у вас нет

Например, чтобы вы так же легко могли открыть агент любого юнита или любой другой объект, связанный с юнитом</value>
            </setting>
            <setting name="Module2_Vopros0" serializeAs="String">
                <value>Убийство выбранного юнита при вводе команды в чат</value>
            </setting>
            <setting name="Module2_Vopros1" serializeAs="String">
                <value>Событие, которое срабатывает после определенного времени</value>
            </setting>
            <setting name="Module2_Otvet1" serializeAs="String">
                <value>За это отвечает событие "Time Elapsed" и "Periodic Event"
Находятся они по метке "Time" (Рисунок 0)

Вариант 1: Time Elapsed
Это событие отвечает за "Время прошло" и запускается один раз
Можно указывать время в секундах и тип времени (Рисунок 1)

Добавив вывод сообщения со временем миссии в чат, увидим такую картину (Рисунок 2)

Вариант 2: Periodic Event
Это событие отвечает за периодические события и запускается бесконечное кол-во раз
Так же можно указывать время в секундах и тип времени (Рисунок 3)

Добавив вывод сообщения со временем миссии в чат, увидим такую картину (Рисунок 4)</value>
            </setting>
            <setting name="Module2_Vopros2" serializeAs="String">
                <value>Подъем и спад лавы + урон</value>
            </setting>
            <setting name="Module2_Otvet2" serializeAs="String">
                <value>Создадим простой рельеф для поднятия лавы (Рисунок 0)
Добавим лаву (Рисунок 1)
Откроем настройки воды (Рисунок 2)
Добавим новое состояние воды и сделаем цвет такой же, как в "По умолчанию" 
Так же укажем нужную нам высоту для поднятой лавы. (Рисунок 3)
Зайдем в триггеры и создадим триггер, отвечающий за подъем и спад лавы. (Рисунок 4)
Создадим событие Pereodic Event и укажем время, через которое будет подниматься лава. (Рисунок 5)
Создадим условие (If) (Рисунок 6)
Создадим глобальную переменную Lava Up/Down с типом "Булево" (Рисунок 7)
В условии будем проверять эту переменную со значением False (Рисунок 8)
В then создадим действие Play Sound и укажем туда звук TUIlavaRising (Рисунок 9)
Создадим действие Set Water State (Рисунок 10)
Где state укажем созданное ранее состояние воды (Рисунок 11)
Где over 1.0 secodns укажем 4 сек.
Далее создадим действие Wait для того, чтобы лава чисто визуально поднялась до нужного уровня,
ниже которого юниты будут получать урон. (Рисунок 12)
Далее создадим действие Turn Trigger On/Off
Где Off меняем на On
Current Trigger пока оставляем как есть (Рисунок 13)
После создадим действие Set Variable 
Где Variable укажем нашу переменную "Lava"
Где Value укажем "Истина" (Рисунок 14)

Теперь в Else скопируем действия:
Play Sound + Set Water State + Wait + Trigger On/Off + Set Variable (Рисунок 15)
Двух секундную задержку в действии Wait меняем на 1.5 сек.
В Set Variable "Истина" меняем на "Ложь", просто убрав галку (Рисунок 16)
В Set Water State меняем состояние на "По умолчанию" (Рисунок 17)
В Trigger On/Off параметр "On" меняем на "Off" (Рисунок 18)

Дальше нужно создать триггер, который будет наносить урон юнитам в лаве
Создадим триггер Lava Damage
Нажимаем на него ПКМ и убираем галку "Изначально включен" (Рисунок 19)
Добавим в него событие "Periodic Event" и установим параметр "Duration" на значение "0.5" (Рисунок 20)
Далее в условии триггера добавим условие (просто crtl + w + enter)
Где Value 1 укажем "Trigger Is On"
Где Value 2 укажем "Истина" (Рисунок 21)
Далее в действиях создаем "Pick Each Unit In Unit Group"(Рисунок 22)
Параметр Unit Group меняем на "Units In Unit group Matching Condition" (Рисунок 23)
Где Unit Filter открываем и двойным кликом меняем "Тип" "Воздушный" и "Неуязвимый" на "Исключено"
Так же снимаем галки "Союзник" и "Противник" (Рисунок 24)
Далее в Actions создаем проверку (If) (Рисунок 25)
Где If создадим условие. В этом в условии:
Где Value 1 поменяем на Height At Point (Рисунок 26)
Где Unit меняем на Picked Unit (Рисунок 27)
Где Operator меняем на &lt;= (Меньше или равно)
Где Value 2 указываем значение, которое чуть меньше чем высота поднятой лавы. (Рисунок 28)
Это нужно для того, чтобы юниты получали урон, зайдя в лаву, а не приблизившись к ней.
Далее в Then добавим действие Add Behavior (Player) (Рисунок 29)
Где Behavior укажем "Лава (урон)" (Рисунок 30)
Где Unit укажем Picked Unit (Рисунок 31)
Где Player укажем 15
Триггер на получение урона готов. (Рисунок 32)

Теперь нужно вернуться в триггер, который поднимает и опускает лаву.
В нем в обоих Trigger On/Off, где "Current Trigger" меняем на наш триггер получения урона.
(Рисунок 33)</value>
            </setting>
            <setting name="Module3_Vopros2" serializeAs="String">
                <value>Как добавить на карту всех юнитов (протосов-подвиды талдаримы, неразимы и т.д и другие расы)?</value>
            </setting>
            <setting name="Module3_Otvet2" serializeAs="String">
                <value>При создании карты, указывайте карту игротеки или модификацию (Рисунок 0)
Вы можете нажать "стандарт", выбрать нужную кампанию и установить галку "данные кампании" (Рисунок 1)
Но со временем я выяснил, что он не всегда включает все данные, всех трех кампаний и по этому сделаем по-другому
Нажимаем "По выбору" (Рисунок 2)
Нажимаем "Стандарт" и указываем галки всех трех кампаний + по желанию Nova (Рисунок 3)
Не указываем "Сетевой режим" вместе с ресурсами кампании, так как они будут конфликтовать
В итоге получится такой список (Рисунок 4)
Теперь нам доступны юниты из всех кампаний (Рисунок 5)</value>
            </setting>
            <setting name="Module2_Vopros3" serializeAs="String">
                <value>Смена освещения на карте</value>
            </setting>
            <setting name="Module2_Otvet3" serializeAs="String">
                <value>Для начала можете открыть отдельное окно со всеми освещениями (Рисунок 0 и Рисунок 1)
Это может быть полезно для того, чтобы посмотреть, как на вашей карте будет выглядеть конкретное освещение
Варианты освещения можно нажимать и смотреть (Рисунок 2 и Рисунок 3)

Чтобы применить понравившееся, нужно в модуле триггеров, создать действие "Set lighting" (Рисунок 4)
Где Light - указываете освещение (Рисунок 5)
Где Blend Time - указываете время, в течение которого применится освещение (Рисунок 6)
Если указать 0, то оно будет применено мгновенно

Освещение обратно не сменится, пока вы сами не создадите действие триггеров, на применение другого освещения карты.</value>
            </setting>
            <setting name="Module3_Vopros3" serializeAs="String">
                <value>Как сделать так что-бы за каждый выстрел (например морпеха) тратилась 1 единица энергии?</value>
            </setting>
            <setting name="Module3_Otvet3" serializeAs="String">
                <value>В данных, во вкладке "Единицы", найдите юнита, которому вы хотите сделать атаку за энергию (Рисунок 0)
Измените ему поле "Начальный запас энергии" и "Максимальное кол-во энергии" на нужное вам значение (например, 10) (Рисунок 1 и 2)
Проверьте, чтобы "Скорость восстановления энергии была равна нулю" (Рисунок 2)
Далее во вкладке "Оружие", или перейдя прямо к нему из связанных объектов с единицей, найдите оружие вашего юнита (Рисунок 3)
Найдите у него поле "Стоимость +" (Рисунок 4)
Где "Основные показатели", измените "Энергия" на требуемое значение для каждой атаки (например, 1) (Рисунок 5)
Нажмите ОК

Теперь при атаке юнит будет расходовать собственную энергию, а когда она закончится, он не сможет атаковать.</value>
            </setting>
            <setting name="Module3_Vopros4" serializeAs="String">
                <value>Изменение размера юнита</value>
            </setting>
            <setting name="Module3_Otvet4" serializeAs="String">
                <value>В данных найдите своего юнита, которому хотите изменить размер (Рисунок 0)

Способ 1:
У него найдите агент (Рисунок 1) и свойство "Шкала" (Рисунок 2)
Чтобы понять как вам указать нужный размер, нужно понять как в ск2 выглядят проценты
1 - это означает 100%
0.1 - это означает 10%
0.01 - это означает 1%
Что касается размера юнита, то по умолчанию 100%, и если вы хотите изменить размер, то нужно указывать число после единицы или вместо единицы
Например:
2 - увеличение размера на 100%
1.1 - увеличение размера на 10%
1.01 - увеличение размера на 1%

Изменим размер на 100% (Рисунок 3)
Теперь морпех увеличился в 2 раза (Рисунок 4)

Способ 2:
У вашего юнита найдите основную модель (Рисунок 5)
Там найдите и измените поле "Минимальный масштаб" и "Максимальный масштаб" (Рисунок 6 и 7)</value>
            </setting>
            <setting name="Module3_Vopros5" serializeAs="String">
                <value>Изменение модели юнита</value>
            </setting>
            <setting name="Module3_Otvet5" serializeAs="String">
                <value>Разместим на карте юнита, которому хотим изменить модель (Рисунок 0)

В данных найдем этого юнита (Рисунок 1)
Вариант 1:
У него откроем агент (Рисунок 2)
Найдем поля: Модель, Модель (постройка) и Модель (размещение) (Рисунок 3)
Таким способом вы можете изменить текущую модель на другую, со всеми настройками
Но для этого нужно понимать, какую именно модель нужно выбирать
Если вам нужна модель юнита, то чаще всего они будут иметь название без лишних частей
Например: Marine, Medivac, Mothership и тд.
Так же, в списке сортировки, вы можете указать тип "Unit" (Рисунок 4)
Но минус такого способа в том, что близзард наделали кучу типов, с конкретным названием юнита и вы можете не найти основную модель нужного юнита
Пример можно увидеть на Рисунке 5 и Рисунке 6

Укажем модель пилона (Рисунок 7) и укажем их в оставшиеся 2 поля (Рисунок 8)
Вы можете нажать Ctrl + C на первое поле и Ctrl + V на оставшиеся 2 поля
Теперь морпех у нас выглядит как пилон (Рисунок 9 и Рисунок 10)

Вариант 2:
Найдите у вашего юнита основную модель (Рисунок 11)
Найдите у нее поле "Модель" (Рисунок 12)
Открыв его, нажмите "Обзор" (Рисунок 13)
В списке найдите нужную модель (Рисунок 14)
Я указал в качестве примера модель крейсера (Рисунок 15)
Теперь морпех выглядит как крейсер (Рисунок 16 и Рисунок 17)</value>
            </setting>
            <setting name="Module1_Vopros0" serializeAs="String">
                <value>Все юниты вдруг начали летать, как это изменить?</value>
            </setting>
            <setting name="Module1_Otvet0" serializeAs="String">
                <value>Все юниты вдруг начали летать, как это изменить?

За это отвечает поле высот. Если оно настроено не правильно, юниты будут "летать"
Я создал простую поверхность, чтобы показать, как это работает (Рисунок 0-2)
Как видим, все нормально, юниты не "летают", а стоят на земле
Но если мы подведем морпеха в яму, то увидим, что он стоит "на воздухе" (Рисунок 3)
По умолчанию базовая высота равна 8 единицам (Рисунок 4)
Посмотреть и изменить это значение можно в настройках карты (Рисунок 5)
Так же, чтобы понять какая именно высота вам нужна, нужно включить ее отображение на поверхности (Рисунок 6)
Теперь на поверхности видим оранжевые полости, показывающие ниже какой высоты не может опуститься юнит (Рисунок 7)
Это можно изменить, просто убрав галку "Базовая высота для всех боевых единиц" (Рисунок 8)
Теперь юниты смогут спускаться в ямы, а не ходить "по воздуху"

Но это не решает проблему того, что юниты вдруг начали "летать"
Чтобы это исправить, нужно проверить, чтобы базовая высота была равна 8 единицам, как это должно быть по умолчанию
Возможно, конкретно для вашей карты нужно будет другое значение и тут только экспериментировать
Перед тем, как изменять высоту, сохраните копию карты, так как изменение высоты может привести к необратимому выравниванию поверхности

Теперь рассмотрим вариант по теме вопроса:
Изменим высоту, например на 10 единиц и видим, что над поверхностью имеется оранжевый квадрат по всей карте
Теперь это минимальная высота для юнитов и это приводит к тому, что они летают (Рисунок 9)
Запустив игру, мы можем наблюдать следующую картину (Рисунок 10)
Все юниты, включая даже минералы, находятся "в воздухе"
Исправляем это изменением высоты до значения по умолчанию (то есть 8 единиц)</value>
            </setting>
            <setting name="Module2_Vopros4" serializeAs="String">
                <value>Смена скинов юнитов</value>
            </setting>
            <setting name="Module2_Otvet4" serializeAs="String">
                <value>Смена скинов происходит через действия триггеров

Для начала разместим несколько юнитов, для того, чтобы посмотреть, что это работает (Рисунок 0)
Далее заходим в модуль Триггеров и выбираем созданный по умолчанию триггер "Инициализация схватки"
У него в действиях нужно создать "Apply Player Skin" (Рисунок 1)
Там есть просто "Apply Player Skin" и "Apply Player Skin (Peplacing Existing Unit)"
Apply Player Skin - применяет скин, но не заменяет модели у уже размещенных на карте юнитов
Apply Player Skin (Peplacing Existing Unit) - делает тоже самое, только заменяет модели у уже размещенных на карте юнитов

Создадим оба этих действия для наглядности (Рисунок 2)
Теперь выбираем любое из этих действий и где "No Game Link", мы можем указать конкретный скин 
(Рисунок 3)
Но проблема в том, что они все называются одинаково и если вам нужен один конкретный скин, его будет найти очень сложно
Например, на этой тестовой карте, я хочу использовать только гидралисков и гиблингов 
Чтобы их найти, придется буквально все скины перебирать по одному, чтобы найти нужный

Чтобы этого не делать, мы зайдем в модуль Данных и откроем там вкладку "Облики" из раздела "Герой" (Рисунок 4)
Теперь мы видим все доступные скины (Рисунок 5)
Далее мы просто нажимаем на любой из них и в свойствах ищем поле "Отобразить модель+"
В этом после написано имя юнита, которому будет заменена модель
Если вы все еще не можете понять что это за юнит, вы можете открыть поле "Значок вариаций" 
(Рисунок 7 и 8)

Теперь, чтобы нам упростить себе жизнь, мы можем добавить "Префикс редактора" или "Суффикс редактора"
Это нужно для того, чтобы в триггерах проще было найти нужный скин
Например, я добавлю "Префикс" на скин для гиблингов и гидралисков
(Префикс и Суффикс - это тоже свойства, как и "Отобразить модель+")

Далее вернувшись в триггеры, я могу при помощи поиска легко найти нужные мне скины (Рисунок 9)
Установлю скины таким образом:
Apply Player Skin - Выберу там гиблингов
Apply Player Skin (Peplacing Existing Unit) - Выберу там гидралисков (Рисунок 10)

Запустив игру, мы можем видеть, что у гиблингов скин не поменялся, а у гидралисков поменялся (Рисунок 11)
Это связно с тем, что гиблинги сразу есть на карте и скины будут применены только к новым, созданным юнитам (Рисунок 12)

Таким образом, мы выяснили, что нужно использовать "Apply Player Skin (Peplacing Existing Unit)"
Так же, при смене скинов, нужно указывать игрока (по умолчанию 1)
Если у вас на карте 10 игроков, то скины нужно применять для всех
Еще если вы хотите все скины, то их так же, все нужно указывать при помощи действий триггеров (Рисунок 13)
На скриншоте я указал не все, так как это просто пример

Теперь вариант, как можно все эти скины, применить ко всем 10-ти игрокам
Вы можете создать цикл, который сделает все за вас
Создадим "Pick Each Integer"(Рисунок 14) и поместим наши действия на смену скинов, в этот цикл (Рисунок 15)
Начало и конец цикла можно менять (Рисунок 16)
Теперь в наших действиях по смене скинов, где "Player 1", открываем, меняем на "Функция" и указываем "Picked Integer" (Рисунок 17)
Теперь вы можете просто скопировать этот параметр для остальных действий (Рисунок 18 и 19)</value>
            </setting>
            <setting name="Module11_Vopros0" serializeAs="String">
                <value>Как скачать и редактировать карту из игротеки?</value>
            </setting>
            <setting name="Module11_Otvet0" serializeAs="String">
                <value>Чтобы открыть карту опубликованные карты, нужно для начала нажать кнопку открытия карты (Рисунок 1)
Потом нужно переключиться на вкладку "Blizzard" и авторизоваться (Рисунок 2)
Там можно еще выбрать регион, но в теории, он сам его определит при авторизации
Если этого не произошло, попробуйте указать его вручную

Теперь вы можете указать "Источник" (Рисунок 3)
Выбрав один из источников, найдите в списке нужную карту, нажмите "Загрузить" и нажмите "ОК" (Рисунок 4)

Все готово, вы открыли опубликованную карту и можете ее редактировать.
При открытии опубликованных карт, есть нюанс, а именно: вы не можете открыть и редактировать "Закрытые карты"
Если нужная вам карта не находится по названию и последним сыгранным играм, возможно она закрыта для редактирования.
При публикации карты, каждый автор указывает, можно или нельзя ли будет редактировать его карту.
Так же, если вы являетесь автором этой карты и утратили исходники, то скорее всего тут ничего не поделать, так как даже собственные карты нельзя открывать таким способом.

Если вы хотите скачать какую-то свою карту, то можете использовать "Управление опубликованными материалами" (Рисунок 5)
Что представляет из себя почти тоже самое, только отображает карты, опубликованные вами.</value>
            </setting>
            <setting name="Module2_Vopros5" serializeAs="String">
                <value>Как сделать другого игрока союзником?</value>
            </setting>
            <setting name="Module2_Otvet5" serializeAs="String">
                <value>Зайдем в модуль Триггеров и откроем созданный по умолчанию триггер "Инициализация схватки"

Вариант 1: Самый простой
В действиях этого триггера, создадим "Set Alliance" (Рисунок 0)
Это действие позволяет задать союз между двумя игроками (Рисунок 1)
Где Source Player и Target Player можете указывать двух игроков, которые должны быть в союзе
Так же вы можете выбрать варианты союзов:
1) Просто союзники (без общего обзора)
2) Союзники с общим обзором
3) Союзники с общим обзором и контролем
4) Союзники с общим обзором и чем-то еще (не проверял)
5) Союзники с общим обзором, контролем и припасами/ресурсами (не точно)
6) Враги
7) Враги с общим обзором
8) Нейтралы
9) Нейтралы с общим обзором
10) Нейтралы с общим обзором и чем-то еще (не проверял)
(Рисунок 2)

Если на карте много игроков, такой способ будет не очень удобен, так как каждый игрок должен быть в союзе со всеми остальными игроками
Вам придется много раз копировать это действие и вручную указывать союзы для каждого игрока

Вариант 2: Сложнее, но удобнее
Будем использовать переменную для удобства добавления игроков
Так как союзы задаются в основном при старте карты, то использовать эту переменную как глобальную нет смысла, и поэтому создадим ее как локальную
Нажимаем на "Local Variables" и нажимаем Ctrl + W (это создать новый элемент)
Созданную переменную назовем "Player Group" и укажем ей тип "Группа игрока" (Рисунок 3)
Далее создадим действие "Add Player To Player Group" (Рисунок 4 и 5)
Где Player Group нажимаем и выбираем нашу переменную "Player Group" (Рисунок 6)
Таким образом, копируем наше получившееся действие, сколько нам нужно (например, 4 раза) и меняем игроков (Рисунок 7)
Создадим действие "Set alliance For Player Group" (Рисунок 8)
Где Player Group нажимаем и выбираем нашу переменную

Теперь игроки будут союзниками.
Если у вас 15 игроков и вам нужно чтобы они были союзниками, то вы можете использовать цикл, для добавления всех игроков в группу.</value>
            </setting>
            <setting name="Module1_Vopros1" serializeAs="String">
                <value>Пропала/не отображается панель редактирования поверхности, как исправить?</value>
            </setting>
            <setting name="Module1_Otvet1" serializeAs="String">
                <value>Представим такую картину, что вы впервые открыли редактор или случайно что-то нажали и у вас не отображается панель редактирования поверхности (Рисунок 0)
Все, что вам нужно сделать, так это нажать кнопку "Вид" на верхней панели и снова включить "Показать панель интерфейса" (Рисунок 1)

Теперь вы снова можете редактировать поверхность. (Рисунок 2)</value>
            </setting>
            <setting name="Module1_Vopros2" serializeAs="String">
                <value>Не отображаются кнопки редактирования поверхности, как исправить?</value>
            </setting>
            <setting name="Module1_Otvet2" serializeAs="String">
                <value>Представим такую картину, что вы впервые открыли редактор или случайно что-то сделали и у вас не отображаются кнопки редактирования поверхности (Рисунок 0)
Все, что вам нужно сделать, так это либо нажать на стрелки, либо навестись мышкой на одну из видимых кнопок и прокрутить колесико мыши вверх (Рисунок 1)

Теперь вы снова можете редактировать поверхность. (Рисунок 2)</value>
            </setting>
            <setting name="Module3_Vopros6" serializeAs="String">
                <value>Изменение цвета юнита</value>
            </setting>
            <setting name="Module3_Vopros7" serializeAs="String">
                <value>Изменение дальности оружия</value>
            </setting>
            <setting name="Module3_Vopros8" serializeAs="String">
                <value>Изменение скорости атаки оружия</value>
            </setting>
            <setting name="Module3_Vopros9" serializeAs="String">
                <value>Изменение урона оружия юнита</value>
            </setting>
            <setting name="Module3_Otvet6" serializeAs="String">
                <value>Найдите юнита, которому вы хотите изменить цвет.
Откройте его Агент (Рисунок 0) и найдите поле "События+". (Рисунок 1)
Открыв события, нажмите ПКМ в любом свободном месте.
Из появившегося списка выберите "Добавить событие". (Рисунок 2)
Будет создано событие с прикрепленным к нему действием. (Рисунок 3)
Тип сообщения меняете на "Создание агента".
Далее выбираем действие и меняем его на "Задать оттенок".
В конце можно будет наглядно увидеть разницу между двумя юнитами.
Все параметры оставляете без изменений и указываете только нужный цвет и жмете ок.
После снова нажимаете ок и все готово. (Рисунок 7)
Рисунок 8 - Вид из редактора.
Рисунок 9 - Вид из игры.</value>
            </setting>
            <setting name="Module3_Otvet9" serializeAs="String">
                <value>Для того, что изменить урон оружия юнита, нужно для начала найти эффект урона, который наносит это оружие
Нажмите на оружие юнита и посмотрите, какой эффект указан в поле "Эффект" (Рисунок 0)
Так как у морпеха оружие не имеет снаряда, то у него в оружии сразу указан эффект урона (Рисунок 1)
Перейдя в этот эффект, найдите поле "Количество+"
У морпеха по умолчанию указано значение "6", это и есть урон его оружия
Вы можете менять это значение на любое другое

Вариант 2: Оружие со снарядом
Взяв в пример оружие мародера, видим что у него больше эффектов, связанных с его оружием (Рисунок 2)
Перейдя в его оружие, в поле эффекта, видим эффект запуска снаряда (Рисунок 4)
Теперь прейдем в эффект запуска снаряда, чтобы посмотреть с чем он еще связан (Рисунок 5)
Перейдем и в этот эффект и видим там эффект замедления и эффект нанесения урона (Рисунок 6)
Так мы последовательно выяснили какой именно эффект урона отвечает за его оружие
Это может быть полезно для юнитов, у которых несколько оружий или юнитов, которые используют оружие с несколькими уронами (Например, излучатель пустоты)</value>
            </setting>
            <setting name="Module3_Otvet8" serializeAs="String">
                <value>Для того, что изменить скорость атаки оружия юнита, нужно для начала перейти в его оружие
Нажмите на оружие юнита и найдите после "Интервал" (Рисунок 0)

У мародера по умолчанию 1.5 время между атаками
Вы можете менять это значение на любое другое</value>
            </setting>
            <setting name="Module3_Otvet7" serializeAs="String">
                <value>Для того, что изменить дальность атаки оружия юнита, нужно для начала перейти в его оружие
Нажмите на оружие юнита и найдите после "Дальность" (Рисунок 0)

У мародера по умолчанию дальность 6
Вы можете менять это значение на любое другое</value>
            </setting>
            <setting name="Module10_Vopros0" serializeAs="String">
                <value>Как сделать ботов по сложнее?</value>
            </setting>
            <setting name="Module10_Otvet0" serializeAs="String">
                <value>Чтобы изменить сложность ботов, зайдите для начала в настройки (Рисунок 1)
Перейдите во вкладку "Пробный запуск" и найдите "Сложность игры" (Рисунок 2)
Теперь вы можете изменить сложность ботов по умолчанию</value>
            </setting>
            <setting name="Module2_Vopros6" serializeAs="String">
                <value>Смена дня и ночи</value>
            </setting>
            <setting name="Module2_Otvet6" serializeAs="String">
                <value>Зайдите в Модуль триггеров и создайте новый триггер (Рисунок 0)
Создадим глобальную переменную, которая будет отвечать за День и Ночь 
Назовем ее "Day/Night", укажем тип "Булево" и начальное значение поменяем на "Истина» (Рисунок 1)
Определять будем так:
Истина - это день
Ложь - это ночь

Вернемся в триггер и создадим событие "Map initialization", которое будет выбрано по умолчанию сразу и сработает, как только карта загрузится (Рисунок 2)
Переходим сразу к действиям и создадим бесконечный цикл, который и будет запускать смену дня и ночи
Сделаем каркас для смены для и ночи, а потом сделаем отображения таймера

Создаем действие "Repeat Forever" (Рисунок 3)
В действиях этого цикла создадим "Wait" и укажем в него время, сколько будет идти день
В качестве примера укажу 30 секунд (Рисунок 4)
Так как у нас по умолчанию День и этот триггер сработает при старте карты, то ему нужно только ждать наступление ночи

После Wait создадим действие "Set Lighting" (Рисунок 5)
Где Light - укажем какое-нибудь освещение карты для ночи
Где Blend Time - время, в течение которого применится это освещение (Рисунок 6) (Со временем экспериментируйте)
Чтобы понять, какое освещение вам больше подходит, вы можете посмотреть их в отдельном окне "Освещение" (Рисунок 7, 8 и 9)
Так же можете посмотреть вопрос "Как сменить освещение карты?", чтобы более подробно об этом узнать

Теперь после "Set Lighting" создадим действие "Set Variable" (Рисунок 10)
Где Variable - Укажем нашу переменную (Рисунок 11)
Где Value - Откроем и просто нажмем "Ок", без установки галки на "Истина" (Рисунок 12)
Это мы сделали смену на ночь

Теперь сделаем смену на день
Скопируем "Wait" и вставим его после "Set Value" (Рисунок 13)
Значение в этом ожидании, будет означать, сколько длится ночь
Скопируем так же "Set Light" и вставим его после "Wait" 
Как и в прошлый раз, изменим освещение на дневное (в моем случае это Argia) (Рисунок 14)
Скопируем "Set Variable" и изменим значение "Flalse" на "Истина" (Рисунок 15)

Каркас для смены дня и ночи готов.
Теперь можно прикрутить сюда таймер, для отображения длительности дня и ночи.

Создадим одну локальную переменную, назовем ее "Time of Day" и укажем тип "Таймер" (Рисунок 16)
Тут же, сразу создадим переменную, для отображения нашего таймера
Создаем еще одну локальную переменную, назовем ее "Timer Window" и укажем тип "Timer Window" (Рисунок 17)

Теперь в цикле, перед ожиданием для ночи, создадим действие "Start Timer" (Рисунок 18)
Где Timer - Открываем и указываем нашу переменную "Time of Day"
Где One Shot - Оставляем без изменений
Где Duration - Укажем, сколько времени осталось до наступления ночи
В моем случае это 30 секунд

После создаем "Set Variable"
Где Variable - Укажем нашу переменную таймера "Time of Day" (Рисунок 19)
Где Value - Откроем, переключим на "функция" и укажем "Last Started Timer" (Рисунок 20)

Создадим следующее действие "Create Timer Window" (Рисунок 21)
Где Last Started Timer - Откроем, переключим на "Переменная" и укажем нашу переменную "Time of Day"
Где Title - Можете написать что-то вроде "День" (Рисунок 22)

Так же, после этого создадим действие "Set Variable"
Где Variable - Укажем нашу переменную "Timer Window"
Где Value - Откроем, переключим на "функция" и укажем "Last Created Timer Window" (Рисунок 23)

Теперь 4 действия, связанные с таймером скопируйте и вставьте после наступления ночи
То есть после "Set Variable" со значением "False" (Рисунок 24)
В "Create Timer Window" измените текст "День", на "Ночь"
В "Start Timer" измените, время на то, сколько у вас длится ночь (Рисунок 25)

Уже в процессе добавления вопроса, заметил, что забыл дописать одну строку, из-за которой у вас с каждым новым днем или ночью, будет создаваться новое окно с таймером
Это не правильно, он должен удалять старый и создавать новый
Вам нужно только добавить 2 действия "Destroy Timer Window" и указать туда переменную "Timer Window"
Разместить их перед действием "Create Timer Window"
Рисунок я добавил в самый конец (Рисунок 32)

Все готово.
Теперь у вас будет смена дня и ночи.

Такой способ очень простой и без лишних заморочек.
Если вы хотите привязать какие-то события на срабатывание таймера дня и ночи, то переменную "Time of Day" вам нужно будет просто перенести из локальных, в глобальные.
Потому что если переменная локальная, то вы не сможете получить к ней доступ из других триггеров.

Вот как перенести ее:
Скопируйте ее, нажмите на любой триггер или глобальную переменную и вставьте (Рисунок 26 и 27)
Вернитесь в триггер, нажмите на локальную версию этой переменной и нажмите "Delete" (Рисунок 28)
Он вам покажет, что она задействована N кол-во раз
Нажимаем "Ок" и видим что везде, где она использовалась, подсвечивает красным (Рисунок 29)
Теперь просто вручную указываем нашу глобальную переменную (Рисунок 30 и 31)

Но с точки зрения удобства, это не очень правильно.
Вы можете использовать нажать на локальную переменную и нажать Ctrl + F10, чтобы посмотреть, где она используется.
Так же, вы можете нажимать двойным кликом и переходить в конкретное место, к конкретному действию или функции, где используется переменная.
Это будет более правильно и более удобно.
На скришотах я показал вариант, когда триггер не большой и переменная почти нигде не используется.

Теперь вы перенесли локальную переменную в глобальные и подставили ее везде, где она использовалась.
Так вы сможете использовать ее в других триггерах.</value>
            </setting>
            <setting name="Module2_Vopros7" serializeAs="String">
                <value>Телепорт юнитов из одной точки в другую</value>
            </setting>
            <setting name="Module2_Otvet7" serializeAs="String">
                <value>Создадим простую карту, для демонстрации (Рисунок 0)
Разместим 2 маяка и создадим 2 области прямо на этих маяках (Рисунок 1)
Разместим 2 точки рядом с маяками (Рисунок 2)
Изменим обоим маякам владельца на нейтрального (Рисунок 3)

Зайдем в Модуль Триггеров
Создадим новый триггер и назовем его "Teleport" (Рисунок 4)
Создадим событие "Unit Enters/Leaves Region" (Рисунок 5)
Где Region - Открываем, переключаем на "Значение" и выбираем одну из областей (Рисунок 6)
Скопируем это событие и укажем в нем вторую область (Рисунок 7)

Переходим к условиям и создадим новый элемент (Ctrl + W)(Рисунок 8)
Где Operator - Изменим значение на "!=" 
Где Value 2 - Изменим значение на ноль (Рисунок 9)

Переходим к действиям и создадим действие "If then Else-if" (Рисунок 10)
Создадим в нем новый элемент (Рисунок 11)
В первом из этих элементов создадим условие (Рисунок 12)
Где Value 1 - Укажем "Triggering Region"
Где Value 2 - Укажем одну из областей (Рисунок 13)

Далее, где Then создадим действие "Move Unit Instantly" (Рисунок 14)
Где Point - Укажем точку на противоположной стороне от области, которую вы указали в условии (Рисунок 15)

Скопируем получившееся условие (Рисунок 16)
Теперь в условии изменим область и в действии поменяем точку (Рисунок 17)

Теперь у вас есть телепорт юнитов.

Таким способом вы сможете при желании, добавлять новые области и точки для телепорта
Что касается размещения точек рядом с маяком, а не прямо на маяке, это для того, чтобы юнит зайдя на маяк, не начинал бесконечно телепортироваться с одного маяка на другой
Это можно изменить, придумав способ, благодаря которому один и тот же юнит, не сможет телепортироваться в течение нескольких секунд
Либо пока не сойдет с маяка и не зайдет на него снова</value>
            </setting>
            <setting name="Module2_Vopros8" serializeAs="String">
                <value>Волны врагов из точки в точку</value>
            </setting>
            <setting name="Module2_Otvet8" serializeAs="String">
                <value>Заходим в модуль Триггеров

Рассмотрим 2 варианта:
Вариант 1: Спавн юнита в точке, приказ атаки напрямую, в конечную точку
Вариант 2: Тоже самое, только приказ атаки через ряд точек

Я создам простую поверхность для демонстрации (Рисунок 0)
Откроем триггер "Инициализация схватки" и так как у меня карта чистая, удалим находящиеся в нем действия (Не обязательно) (Рисунок 1)
Создадим в нем действие "Reveal Area"(Рисунок 2) и изменим у него:
Где Area - Нажимаем, переключаем на "Функция" и указываем "Entire map" (Рисунок 3)
Где Duration - Меняем на ноль (Рисунок 4)
(Это действие было не обязательно, оно нужно только для демонстрации)

Вариант 1:
Предположим, что мы хотим сделать такой вариант, когда зерглинги будут бежать из точки 001 в точку 002
Создадим новый триггер (Ctrl + T) (Рисунок 5)
Предположим, что зерглинги будут спавниться через 5 сек. после старта карты
В конце я покажу как сделать чтобы волны атак увеличивались и сделать их периодическими

Создадим событие "Time Elapsed"(Рисунок 6)
Создадим действие "Create units Facing Angle"(Рисунок 7) и изменим у него:
Где Type - Открываем, пишем в поиске "Зерглинг" и выставляем нужные фильтры, которые отсеют ненужных юнитов (Рисунок 8)
Где Point - Открываем и указываем точку 001 (Рисунок 9)

Далее создадим действие "Issue Order" (Рисунок 10) и изменим у него:
Где Unit - Открываем и через поиск находим "Last Created Unit" (Рисунок 11)
Важно: если создаете больше 1 юнита, то тут нужно другое действие
А именно "Issue Order To Unit Group" и где "Group", вы укажете "Last Created Units"
Где Order - Открываем и меняем на "Order Targeting Point" (Рисунок 12)
Где Ability Command - Открываем и указываем "Атаковать" (Рисунок 13)
Где Target Point - Открываем и указываем точку 002

Где Queue - Оставляем без изменений

Запускаем карту и видим следующее:
Зерглинг заспавнился и бежит по прямой из точки 001 в точку 002 (Рисунок 15 и 16)
Минус такого способа в том, что если вам нужно чтобы юниты шли через ряд точек, то они будут их игнорировать и идти по кратчайшему пути в конечную точку

Вариант 2:
Изменим действие "Issue Order"
Где Target Point: Точка 002 - Изменим на точка 003 или точка 004(на ваше усмотрение) (Рисунок 17)

Скопируем и вставим это действие еще раз (Рисунок 18)
Где Queue - Изменим на "After Existing Orders", что означает "После всех приказов" (Рисунок 19)
Где Target Point - Изменим на точку 002 (Рисунок 20)
Для справки: "Replace Existing Orders" означает "Заменить текущие приказы"; "After Existing Orders" означает "После всех приказов"; "Before Existing Orders" не знаю)) никогда не пользовался

Запускаем карту и видим следующее:
Зерглинг заспвнился и бежит по краю карты в конечную точку (Рисунок 20 и 21)

Теперь рассмотрим вариант, когда волны атак будут увеличиваться
Изменим событие триггера на "Periodic Event" и укажем, к примеру, 10 сек. (Рисунок 22)
Изменим в действии "Create Unit Facing Angle", параметр "Count" на 5 (Рисунок 23)
Удалим оба действия "Issue Order" (Рисунок 24)
Создадим действие "Issue Order To Unit Group" (Рисунок 25)
Где Group - Изменим на "Last Created Units" (Рисунок 26)
Где Order - Как и предыдущих вариантах, указываем "Order Targeting Point"
Где Ability Command - Указываем "Атаковать"
Где Target Point - Указываем первую точку пути, которая в моем случае будет точка 003 (Рисунок 27)

Скопируем и вставим это действие еще раз
Где Точка 003 - Изменим на конечную точку (Точка 002). Вы так же можете указывать следующую точку пути.
Где Queue - Изменим на "After Existing Orders" (Рисунок 28)

Сейчас вы можете теперь запустить карту, и увидеть, как зерглинги будут бежать через ряд точек.

Теперь добавим счетчик, который будет увеличивать кол-во зерглингов
Создадим глобальную переменную(Ctrl + B) Units(Рисунок 29)
Тип переменной оставляем без изменений (Целое число)
Изменим ей только начальное значение на 5 ед. (Рисунок 30)
Это будет означать, что по умолчанию у нас будет спавниться 5 зерглингов

Вернемся в наш триггер и в действии "Create Units Facing Angle", изменим число на нашу переменную
Для этого нажмите на пятерку, переключите на "Переменная" и укажите нашу переменную (Рисунок 31)

Теперь после всех действий, в конце создадим действие "Modify Variable (Integer)" (Рисунок 32)
Где Variable - Указываем нашу переменную
Где Value - Указываем число, на которое будет увеличиваться кол-во зерглингов после каждого спавна
(Рисунок 33)</value>
            </setting>
            <setting name="Module2_Vopros9" serializeAs="String">
                <value>Создание дополнительных кнопок выбора чего-либо в лобби карты (Например, уровень сложности)</value>
            </setting>
            <setting name="Module2_Otvet9" serializeAs="String">
                <value>Чтобы добавить новые кнопки в лобби, нужно создавать атрибуты

На верхнем меню открываем "Карта" - "Атрибуты игры" (Рисунок 0)
Откроется менюшка, в которой как раз и можно создавать эти атрибуты (Рисунок 1)
Создаем новый атрибут, нажав на зеленый плюс (Рисунок 2)

Тут 2 варианта атрибутов:
Тип "Игра" - Этот атрибут будет находиться там же, где и "Скорость игры", "Время матча" и "Команды" (Рисунок 3)
Тип "Игрок" - Этот атрибут будет находиться там же, где и "Цвет", "Раса" и "Гандикап" (Рисунок 4)

Перейдя во вкладку "Использование", вы можете менять следующие параметры:
Параметр Действие - Там есть "Всегда" и "Первому гостю первое место" (Рисунок 5)

"Всегда" - Означает что значение этого атрибута, можно будет менять на любой другой
Так же, можно будет указывать одинаковые значения, даже если его выбрал другой игрок

"Первому гостю первое место" - Означает что значение этого атрибута, можно будет выбрать только 1 раз и если его не выбрал другой игрок
При входе новых игроков, им автоматически будет указано следующее значение по списку
Например, у вас есть атрибут с 6-ю значениями и если добавить 3х игроков, то игра автоматически укажет им значения: 2 3 и 4 (Рисунок 6)

Параметр Видимость - Там есть "Все игроки", "Никто", "Только сам игрок" и "Только создатель игры"

"Все игроки" - Параметр будет виден всем игрокам, как на Рисунке 3 и 4
"Никто" - Параметр НЕ будет виден никому в лобби (Рисунок 8)
"Только сам игрок" - Параметр будет виден только вам и НЕ будет виден остальным (Рисунок 9)
"Только создатель игры" - Параметр будет виден только тому, кто создал лобби карты

Параметр Доступ - Там есть "Все игроки", "Нет", "Только сам игрок" и "Только создатель игры"

"Все игроки" - Параметр может менять любой игрок в лобби
"Нет" - Параметр НЕ сможет менять никто из игроков в лобби (Рисунок 11)
"Только сам игрок" - Параметр сможет менять только сам игрок и более никто из игроков в лобби
"Только создатель игры" - Параметр сможет менять только создатель лобби и более никто
В теории, если человек, создавший лобби, передаст лидера кому-то другому, то новый лидер лобби сможет менять этот параметр

Параметр Применение - Там есть 2 галки, которые я никогда не использовал и могу судить только по подсказкам, которые вы можете прочитать, наведя курсор на них (Рисунок 12)

Перейдя во вкладку "Значение", вы сможете добавить любые варианты этого атрибута
Чтобы это сделать, нажмите зеленый плюс в правой части меню (Рисунок 13)
Так же, вы можете менять:
Их порядок;
Можно применять сортировку в алфавитном порядке;
Можно указывать название варианта значения;
Можно указывать описание; (Рисунок 14)
Можно указывать значок.

Перейдя во вкладку "Начальные значение", вы сможете указывать какие значение вашего параметра будут по умолчанию для каждого игрока
Важно: Если вы указали "Первому гостю первое место", то указываете начальное значение только для Игрока 1 (Рисунок 15)

Теперь рассмотрим как их использовать:
Заходим в модуль триггеров и, к примеру, в "Инициализация схватки" создадим действие Switch (Рисунок 16)
Вы так же можете использовать обычный If Then Else, но я буду использовать Switch, только для удобства отображения

Где Value - Открываем, переключаем на "Функция" и в поиске находим "Attribute Player Value" (Рисунок 17)
Если вы создали параметр с типом "Игра", то вы используете "Attribute Game Value"

Где Attribute - Открываем и в списке находим свой атрибут (Рисунок 18)
Где Единица - Пока оставляем без изменений

Где Cases - Нажимаем Ctrl + W(Создание нового элемента) (Рисунок 19)
Где Value - Открываем, указываем свой атрибут и указываем значение (Рисунок 20)

Повторяем это действие для остальных значений (Я сделаю для примера только 3) (Рисунок 21)
Теперь создадим цикл, который будет проверять всех игроков
Создаем действие Pick Each Integer (Рисунок 22)

Где Start - Нужно указать номер игрока, с которого у вас начинается отсчет игроков
Посмотреть это можно в "Параметры игроков", которые можно найти на верхней панели, в пункте "Карта"
По умолчанию это игрок 1

Где End - Нужно указать номер игрока, на котором у вас кончается отсчет игроков
Предположим что это игрок 5 (Рисунок 23)

Поместим Switch в наш цикл (Рисунок 24)
В Switch, в параметре "Player", открываем и переключаем на "Функция"
Там через поиск находим "Picked Integer" (Рисунок 25)

Готово.
Теперь вы можете использовать параметр игрока для каких-нибудь действий
Учтите, что если один и тот же параметр может выбрать несколько игроков, то логику нужно будет подстраивать под такой случай
С этим у вас могут возникнуть проблемы и лучше напишите об этом в ЛС группы ВК, чтобы я помог вам разобраться

Последний вариант, это параметр с типом "Игра"
Вытягиваем Switch из цикла, а сам цикл удаляем (Рисунок 26)
Где Value в Switch (не в cases) - Меняем "Attribute Player Value" на "Attribute Game Value" и указываем наш атрибут (Рисунок 27)
В Cases, где Value - По аналогии с предыдущего примера указываете свой атрибут и значение

С атрибутами для "игры" все куда проще, чем для "игрока".</value>
            </setting>
            <setting name="Module2_Vopros10" serializeAs="String">
                <value>Как сделать затемнение экрана?</value>
            </setting>
            <setting name="Module11_Vopros1" serializeAs="String">
                <value>Смена языка в редакторе</value>
            </setting>
            <setting name="Module11_Otvet1" serializeAs="String">
                <value>Откройте любой модуль редактора

На вехней панели нажмите "Файл" - Настройка редактора (Рисунок 1)
Перейдите на вкладку "Общие" и где "Регион" смените на любой другой (Рисунок 2)
Если нет доступных языков, то нажмтие кнопку "Проверка", он попросит авторизоваться в вашем аккаунте и после этого у вас должны появится другие языки

Если у вас 300iq, вы играете на пиратке и у вас редактор на немецком/китайском/французском, то тут либо качайте другую пиратку, либо тут ничего не поделать, либо тут только бог поможет.</value>
            </setting>
            <setting name="Module3_Vopros10" serializeAs="String">
                <value>Измение брони юнита</value>
            </setting>
            <setting name="Module3_Otvet10" serializeAs="String">
                <value>Для того, чтобы изменить броню юнита, вам нужно найти и выбрать его во вкладке "Единицы" (Рисунок 0)
Потом найдите у него поле "Игнорируемый урон" (Рисунок 1)
У морпеха по умолчанию 0 брони
Изменим, к примеру, до 5 единиц (Рисунок 2)
Теперь у морпеха 5 брони (Рисунок 3)</value>
            </setting>
            <setting name="Module11_Vopros2" serializeAs="String">
                <value>Настройки редактора</value>
            </setting>
            <setting name="Module11_Otvet2" serializeAs="String">
                <value>Вот эти настройки вы можете изменить под себя, для удобства использования редактора
Найти их можно нажав "Файл" - "Настройка редактора..." (Рисунок 1)

Для начала: Пробный запуск (Рисунок 2)
Тут вы можете установить сложность ботов по умолчанию;
Скорость игры;
Режим экрана;
И какие окна будут сворачиваться при запуске карты.

Далее: Видео (Рисунок 3)
Тут вы можете изменить настройки графики при запуске из редактора
Или же установить галку, чтобы он подгонял настройки в соответствии с теми, что вы выбрали в игре

Далее: Документы (Рисунок 4)
Тут вы можете выбрать одby из вариантов для сохранения карт
"Скорость" - В теории, этот параметр будет ускорять сохранение карты, но у нее будет большой размер
"Мин. размер файлов" - Этот параметр будут оптимизировать размер карты при сохранении

Рекомендую выставить "Мин. размер файлов", так как все-равно при публикации он будет запрашивать установить этот параметр и сохранить карту с оптимизированным размером

"Автосохранение" позволяет выставить таймер, который раз в указанное время будет сохранять карту

Далее: Запуск (Рисунок 5)
Тут вы можете указать, какой модуль будет открываться при запуске редактора и документ при запуске

Какой выбрать модуль решайте сами, а вот документ при запуске рекомендую выставить на "Нет"
Это будет ускорять запуск редактора, так как ему не нужно будет создавать новую карту

Последнее: Общие (Рисунок 6)
Тут вы можете установить лимит ФПС в редакторе и при надобности, сменить язык
Кстати, "темное оформление редактора" работает только на XML)))))))))))))))))))) (Рисунок 7-8)</value>
            </setting>
            <setting name="Module11_Vopros3" serializeAs="String">
                <value>Измение названия и описания карты</value>
            </setting>
            <setting name="Module11_Otvet3" serializeAs="String">
                <value>Чтобы сменить название и описание карты, вам нужно только открыть "Информацию о карте" на верхней панели, во вкладке "Карта" (Рисунок 1 и 2)</value>
            </setting>
            <setting name="Module3_Vopros11" serializeAs="String">
                <value>Способность обучения юнитов</value>
            </setting>
            <setting name="Module3_Otvet11" serializeAs="String">
                <value>Предположим, что вы хотите добавить возможность обучения своих юнитов
Тут есть 2 варианта как это можно сделать

Первый вариант, это когда вы добавляете юнитов в уже созданные способности;
Второй вариант, это когда вы создаете новые способности обучения
Я покажу оба варианта

Вариант 1: Добавление юнитов в уже созданные способности
Способности можно находить в специальной вкладке, сделав поиск по названию, но это не очень практично, 
так как многие способности называются то на русском, то на английском

Проще всего это делать через привязанные объекты к юниту
Для этого возьмем в пример "Казармы" (Рисунок 0)

Слева внизу у нас отображаются привязанные к этому юниты объекты
Пролистаем там вниз и найдем способность "Казармы - Train"(Рисунок 1)

Найдите поле "Информация+" и откройте его (Рисунок 2)
Теперь перед вами список всех юнитов, которых обучить при помощи этой способности (Рисунок 3)
У меня их всего 4, так как я создал карту с ресурсами только одной кампании

Вы можете добавлять любых других юнитов в свободные слоты (Рисунок 4)
Но так же, вам никто не запрещает менять уже созданные слоты
Например, вам не нравится что в казармах обучаются обычные марины
Вы можете этого обычного марина изменить на элитного или вообще танк какой-нибудь
Далее я покажу как это делать, а сейчас рассмотрим как добавлять юнитов в свободные слоты

Двойным кликом откройте любое "Обучение", где ничего не указано, как это показано на (Рисунок 4)
У вас откроется еще одно окно, в котом уже вы и будете настраивать это "Обучение" (Рисунок 5)
1) "Информация - кнопка"
Тут указывайте любую понравившуюся кнопку (Рисунок 6)
Сразу скажу, что лучше указывайте кнопки так, чтобы кнопка в способности и на панели приказов совпадали
Это нужно чисто для вашего же удобства

2) "Информация - требование"
Тут можно указать условия обучения юнита (Рисунок 7)
Например, чтобы его можно было обучить только одного, или только определенное количество, или требовалось какое-нибудь строение/улучшение
Но это отдельная большая тема и тут мы это пропустим

Промотайте вниз чтобы увидеть остальные настройки
3) "Информация - затрачиваемые ресурсы"
Это позволяет указать стоимость обучения/строительства в самой способности (Рисунок 8)
Сказу скажу, что если вы указываете стоимость в способности, то нужно убрать стоимость в самом юните
В противном случае, стоимость будет складываться и если в юните указано 50 минералов, а в способности 100, то будет он стоить 150 минералов

4) "Информация - Заряд"
Это позволяет без требований сделать использование этой способности определенное кол-во раз (Рисунок 9)
Так же можно сделать чтобы новые заряды появлялись через определенное время 

"Заряд - количество (максимальное)"
Это сколько всего зарядов этой способности может быть накоплено

"Заряд - количество (используемое)"
Это сколько зарядов способность будет тратить при использовании

"Заряд - Время (используемое)"
Это время, в течение которого будет накапливаться один новый заряд

5) "Информация - Время"
Это время обучения/строительства юнита (Рисунок 10)
Укажем, к примеру, 10 секунд

6) "Информация - Единица"
Тут как раз и указывается юнит, которого нужно обучить/построить (Рисунок 11)
Нажмите на зеленый плюс (Рисунок 12) и у вас откроется еще одно окно, в котором нужно будет указать юнита (Рисунок 13 и 14)

Готово, теперь просто нажмите везде ОК (Рисунок 15 и 16)

Вернемся к нашему юниту и найдем у него поле "Панель приказов+" (Рисунок 17)
Открыв панель приказов, вы увидите кнопки, которые вы можете видеть в игре (Рисунок 18)

Нажав на любую пустую клетку вы можете добавить свою кнопку (Рисунок 19)
Выбрав кнопку нажмите ОК или двойной клик по кнопке и она у вас появится на панели приказов (Рисунок 20)

Теперь в маленьком окне у вас отображается выбранная вами в данный момент кнопка
Выбирая другие кнопки она будет меняться (Рисунок 21)
Таким образом, вы можете сделать двойной клик по ней и изменить любую уже добавленную кнопку

Но вернемся к нашей добавленной кнопке и тип кнопки поменяем с "Неопределенный" на "Команда способности» (Рисунок 22)
Теперь где "Способность" укажите "Казармы - Train" (Рисунок 23)
И где "Команда способности" нужно указать кнопку, которую вы указывали в способности
Это как то, про что я и говорил, что кнопка в способности и на панели приказов должна совпадать
То есть я указал 2 одинаковые кнопки и мне даже не нужно думать что выбрать из списка (Рисунок 24)

Готово.
Теперь можете везде нажать ОК и запустить карту (Рисунок 25, 26 и 27)

Вариант 2:
Создание своей способности обучения

Тут все практически тоже самое, отличие только в том, что вам нужно создать новую способность и добавить ее юниту
Вернемся во вкладку "Способности" и создадим новую способность нажав в пустом месте ПКМ (Рисунок 28)

Сделайте любое название и любое ID
Тип способности нужно указать "Обучение" (Рисунок 29)
Раса любая
Жмите ОК

У созданной нами способности найдите поле "Информация+" (Рисунок 30)
Тут вы можете видеть все абсолютно тоже самое, что вы и делали ранее
Теперь у вас целых 30 свободных слотов под обучение (Рисунок 31)
По прошлому примеру добавляйте новых юнитов, в конце нажмите везде ОК (Рисунок 32)

После вернитесь к юниту, который должен обучать добавленных нами юнитов (у меня это казармы)
Найдите у него поле "Способности" (Рисунок 33)
Тут вы можете видеть все способности этого юнита (Рисунок 34)

Нам нужно добавить нашу способность
Для этого нажмите зеленый плюс, добавится новый слот "(нет)", нажмите на него и через поиск найдите свою способность (Рисунок 35)
После нажмите ОК

Теперь, как и в прошлом примере, просто добавьте кнопки на панель приказов, и все будет работать</value>
            </setting>
            <setting name="DescriptionUpdates" serializeAs="String">
                <value>Исправлено отображение скриншотов при смене модуля</value>
            </setting>
            <setting name="Module1_Vopros3" serializeAs="String">
                <value>Как добавить на карту больше наборов текстур поверхности?</value>
            </setting>
            <setting name="Module1_Otvet3" serializeAs="String">
                <value>Создадим карту, на которую будем добавлять дополнительные текстуры поверхности (Рисунок 0)
В модуле Поверхности выберите инструмент "Набор текстур" (Рисунок 1)
В этом списке можно увидеть доступные на карте наборы

Так же, на поверхности, будет отображаться красная сетка с цифрами (Рисунок 2)
Эти цифры показывают, в какой области будет находиться конкретный набор текстур

Теперь сохраним карту в виде "папки с компонентами" (Рисунок 3 и 4)
Перейдя в место, куда вы сохранили эту папку, вы можете открыть ее и найти там файл "t3Terrain" в формате "XML" (Рисунок 5)
Откройте его любым текстовым редактором (например, Notepad++), и вернитесь в редактор

Зайдите в Модуль данных, откройте вкладку "Типы поверхности" (Рисунок 6)
Выберите, какие наборы будете добавлять, и далее будем их добавлять (Рисунок 7)
Например, я буду добавлять "Бел-Шир, Гавань, Закул-Дас"

Выбираем Бел-Шир, и делаем двойной клик на значение поля "Название" 
Из этого поля нам нужно скопировать только название набора текстур (Рисунок 8)

Вернемся в открытый файл "t3Terrain", найдем у него поля "textureSetLest" и "textureSet"
Где "textureSet" добавляем скопированное название в name="" (Рисунок 9)
Проделайте такую операцию с каждым набором текстур и не сохраняйте файл, пока открыта карта
В противном случае, это приведет к крашу редактора

Как только добавили до 8 наборов текстур, закройте карту, сохраните файл "t3Terrain" и откройте снова карту
Теперь в инструменте "Набор текстур" у вас появятся добавленные наборы (Рисунок 10)
Вы можете выбирать любой из них, и выбирать области, где его можно будет использовать (Рисунок 11)

Теперь вы можете использовать текстуры из добавленных наборов (Рисунок 12, 13 и 14)
Единственный минус, который никак не исправить, так это невозможность накладывать текстуры друг на друга из разных наборов
Из-за этого могут появятся области, где не полностью была закрашена поверхность (Рисунок 15)</value>
            </setting>
            <setting name="Module11_Vopros4" serializeAs="String">
                <value>Удаление своей карты из игротеки</value>
            </setting>
            <setting name="Module11_Otvet4" serializeAs="String">
                <value>Чтобы удалить карту из игротеки, на верхней панели нажмите "Файл" - "Управление опубликованными материалами" (Рисунок 1)

Войдите в сеть под своим аккаунтом (Рисунок 2)
Выберите свою карту из списка и нажмите "Удалить"

В появившемся окне введите "УДАЛИТЬ" и нажмите ОК (Рисунок 3)
Теперь карта удалена.</value>
            </setting>
            <setting name="Module3_Vopros12" serializeAs="String">
                <value>Как бункеру терранов добавить турель, которая сверху как кампании?</value>
            </setting>
            <setting name="Module3_Otvet12" serializeAs="String">
                <value>Чтобы добавить турель для бункера, нужно сделать улучшение
Сделать его можно двумя способами
Так же, на вашей карте должны быть как минимум ресурсы кампании Wings of Liberty

Способ 1: Через Триггеры
В нужном вам триггере, создайте действие "Set Upgrade Level For Player" (Рисунок 0 и 1)

Где Upgrade - Нужно указать "Story Mode Tech - (Bunker) Турель «Шрайк»" (Рисунок 2)
Где Player - Нужно указать игрока, для которого будет применено улучшение

Предположим, что вы хотите выдать это улучшение для игрока 1, 2 и 3
Скопируем это действие еще 2 раза (Рисунок 3)

В скопированных улучшениях, где Player, изменим на нужных игроков (Рисунок 4)
Теперь можно запустить игру, и увидеть, что у всех трех игроков, на бункерах есть турель (Рисунок 5)

Способ 2: Через Данные
Для начала нужно создать новую способность с типом "Разработка" (Рисунок 6)

Теперь откройте поле "Информация +" (Рисунок 7)
В появившемся окне дважды кликните по "Исследование 01" (Рисунок 8)

Где "Информация - Кнопка" - укажите любую кнопку
Где "Информация - Требование" - укажите "Shrike Turret Not Researched" (Рисунок 9)
Где "Информация - Технология - Затрачиваемые ресурсы" - можете указать стоимость (я не указывал)
Где "Информация - Время" - укажите время разработки улучшения
Где "Информация - Улучшение" - укажите "Story Mode Tech - (Bunker) Турель «Шрайк»" (Рисунок 10)
Нажмите везде ОК, и можно будет продолжить

Теперь во вкладке "Единицы" найдите юнита, который будет разрабатывать это улучшение
В моем примере это будет сам бункер

Найдите у него поле "Способности" (Рисунок 11)
Открыв его, добавьте созданную ранее способность (Рисунок 12)

Теперь найдите поле "Панель приказов" (Рисунок 13)
Добавьте какую-нибудь кнопку на панель приказов (Рисунок 14)
Тип "Неопределенный" поменяйте на "Команда способности", и укажите созданную ранее способность (Рисунок 15)
Нажмите везде ОК

Теперь можно проверить в игре (Рисунок 16, 17 и 18)</value>
            </setting>
            <setting name="Module2_Vopros12" serializeAs="String">
                <value>Диалоги со своим текстом в субтитрах</value>
            </setting>
            <setting name="Module2_Otvet12" serializeAs="String">
                <value>Чтобы сделать диалоги со своим текстом и возможно звуком, вам нужно зайти в Модуль Триггеров
Для примера я сделаю простую карту, в которой КСМ при входе в область, будет воспроизводить диалог (Рисунок 0)

Создадим пустой триггер (Рисунок 1)
Дважды кликните по "Evetns" и укажите там событие "Unit Enters/Leaves Region" (Рисунок 2)
Где Entire Map - Меняем на нужную нам область (Рисунок 3)
Где Unit - Меняем на нужного нам юнита (Рисунок 4)

Теперь дважды кликните по "Actions" и создайте действие "Turn Trigger On/Off" (Рисунок 5)
Это действие будет исключать повторения

После создайте действие "Send Transmission For Player" (Рисунок 6)
Это действие будет воспроизводить диалог

Посмотрим, какие параметры оно имеет (Рисунок 7):
Players - По умолчанию указано All Players, и это будет означать, что диалог будет проигрываться для всех игроков сразу

Unit (подсвечивается красным) - Тут можно указать вашего юнита, который будет "говорить", и от него будет браться портрет

Override Portrait - Do Not означает, что если указан какой-нибудь звук, то он не будет заменять портрет "говорящего" на портрет юнита, которого вы указали

Sound - Тут можно указать уже существующую реплику из игры
Name - Имя "говорящего"
Message - Текст "говорящего"
Portrait и у него чуть ниже есть Position - Это позиция портрета при диалоге (По умолчанию слева по центру)
Duration - Время воспроизведения диалога
WaitUntilDone - Ждать или не ждать завершения диалога

Остальные параметры я не использовал, и не знаю, что они делают

В игре это выглядит вот так (Рисунок 8)

Это был супер простой вариант использования
Вы можете использовать это действие с разными событиями, такими как: Время прошло/периодическое событие/Единица погибает и тд.
Вариантов использования очень много и все их рассмотреть не получится

Сейчас я покажу, что тут можно улучшить/изменить под определенные обстоятельства/идеи

1) В событии, где Unit, можно оставить по умолчанию "Any Unit"
А в условия добавить проверку владельца юнита (Рисунок 9 и 10)
В самом действии, где Unit, изменить на "функция" - "Triggering Unit"

Таким образом, при входе в область любого юнита игрока 1, будет срабатывать триггер

2) В условия можно добавить еще одно, проверяющее на определенный тип юнита
Скопируйте существующее условие и где "Value 1" измените на "Unit Type Of Unit" (Рисунок 11)
Где "Value 2" укажите конкретный тип юнита (Например, КСМ)

Теперь триггер будет проверять, чтобы область вошел именно КСМ, и именно игрока 1
Можете использовать либо вместе эти условия, либо по отдельности</value>
            </setting>
            <setting name="Module2_Vopros13" serializeAs="String">
                <value>Почему триггеры на английском?</value>
            </setting>
            <setting name="Module2_Otvet13" serializeAs="String">
                <value>Уже давно, вроде бы с выходом legacy of the void, близы удалили из триггеров русский язык
Все остальные модули редактора остались на русском, а вот триггеры теперь только на английском

Если вы хотите изучать триггеры, то делайте это сразу на английском, так как в этом случае, вы сможете искать ответы на вопросы не только на русском языке, но и на английских форумах/видосах</value>
            </setting>
            <setting name="Module2_Otvet14" serializeAs="String">
                <value>Это делается через триггеры и для примера, я создам простую карту (Рисунок 0)
В этой карте Колосс будет идти по дороге и когда он дойдет до середины, то в конце заспавнятся зерглинги

Так же, вам нужно будет создать область и точку
Область будет отвечать за то, куда должен зайти игрок, для спавна врагов (Рисунок 1)
Точка будет отвечать за то, где будет создаваться враги (Рисунок 2)

Теперь заходим в Модуль Триггеров
Создадим новый триггер и в событие ему укажем "Unit Enters/Leaves Region" (Рисунок 3)

Теперь где "Entire Map" меняем на "Значение - Наша область" (Рисунок 4)
Это будет означать, что при входе любого юнита в область, этот триггер сработает

Теперь нужно указать условие, которое будет проверять, чтобы в область вошел юнит игрока 1
Выбираем условия и создаем новый элемент(Ctrl + W)
По умолчанию там всегда "Сравнение" + "Проверка владельца юнита" и просто сразу жмем ОК (Рисунок 5)

Теперь переходим к действиям и создадим для начала действие, которое будет исключать повторения
Создаем действие "Turn Trigger On/Off" и оставляем все параметры без изменений (Рисунок 6)

Теперь создадим действие на спавн врагов
Создаем "Create Units Facing Angle" и проверяем, чтобы оно было после отключения триггера (Рисунок 7)

Теперь настройка действия: (Рисунок 8 и 9)
Count - Количество создаваемых юнитов
Type - Тип юнита
Player - Владелец созданных юнитов (рекомендую по умолчанию ставить 15, так как если вы его не меняли, то это "Враждебная группировка")
Point - Точка спавна
Angle - Угол разворота юнитов при спавне
Flags - Не пользовался, не знаю)

Учтите, что все создаваемые таким образом юниты, будут созданы мгновенно и при большом их количестве, это может вызвать фриз игры
Запустив игру, можем видеть, что враги заспавнились (Рисунок 10)

Варианты изменения триггера:
1) Несколько игроков
Представим, что у вас 2 или более игроков, которые могут активировать этот триггер
В таком случае, можно доделать условие, добавив еще парочку игроков и добавить эти проверки в "ИЛИ/OR" (Рисунок 11)

2) Создание множества юнитов
Если вы хотите спавнить очень много юнитов (например, 100+), то можете использовать цикл с задержкой
Задержку можете подгонять под себя, но минимум 0.0625 (Рисунок 12)</value>
            </setting>
            <setting name="Module2_Vopros15" serializeAs="String">
                <value>Ограничение размера карты</value>
            </setting>
            <setting name="Module2_Otvet15" serializeAs="String">
                <value>Это делается через триггеры и для примера, я создам простую карту (Рисунок 0)
Размер этой карты будет 128x128, но при старте игры он будет уменьшен до размера "области 001"
Затем, когда игрок достигнет области "Map 1", карта увеличится до "области 002"
Под конец, когда игрок достигнет области "Map 2", карта увеличится до максимального размера

Учтите, то карта может быть только квадратной или прямоугольной
Сделать ее квадратной, но вырезав какой-либо кусок от него нельзя

Заходим в Модуль Триггеров
Выбираем созданный по умолчанию триггер "Инициализация схватки"
Так как для меня это тестовая карта, то я удалю из него не нужные действия (Рисунок 1)

Создадим действие "Set Playable Map Area" (Рисунок 2)
Где Region - Укажем нашу первую область, которая отвечает за стартовую доступную карту 
В моем случае это "область 001" (Рисунок 3)

Теперь запустив игру, мы видим, что наша карта уменьшилась (Рисунок 4)

Теперь надо создать триггеры, которые будут расширять нашу карту
Создадим новый триггер (Рисунок 5)

В событиях укажем "Unit Enters/Leaves Region" (Рисунок 6)
Где Region - Укажем область "Map 1" (Рисунок 7)

Создадим условие, которое будет проверять, чтобы в область вошел юнит игрока 1
Выбираем условия и создаем новый элемент(Ctrl + W)
По умолчанию там всегда "Сравнение" + "Проверка владельца юнита" и просто сразу жмем ОК (Рисунок 8)

Теперь переходим к действиям и создадим для начала действие, которое будет исключать повторения
Создаем действие "Turn Trigger On/Off" и оставляем все параметры без изменений (Рисунок 9)

Далее просто создадим снова "Set Playable Map Area" и укажем "область 002" (Рисунок 10)
Запустив игру и зайдя в область "Map 1", видим, что карта увеличилась (Рисунок 11)
Теперь мы можем продвинуться дальше по карте (Рисунок 12)

Дальше чтобы вам не повторять все предыдущие действия, вы можете буквально скопировать и вставить созданный триггер
Копируем его и изменяем:
В событии - Область расширения карты "Map 1" на "Map 2"
В действиях - Область новой карты "002" на "Функция - Entire Map" (Рисунок 13)

Теперь запустив игру и зайдя в область "Map 2", видим, что карта увеличилась до максимального размера (Рисунок 14)
После этого мы так же можем пройти дальше (Рисунок 15 и 16)</value>
            </setting>
            <setting name="Module2_Otvet16" serializeAs="String">
                <value>Это делается через триггеры и для примера, я создам простую карту (Рисунок 0)
Представим, что я хочу, чтобы начальное положение камеры было в точке, которую я укажу

Заходим в Модуль Триггеров
Выбираем созданный по умолчанию триггер "Инициализация схватки"
Так как для меня это тестовая карта, то я удалю из него не нужные действия (Рисунок 1)

Создадим действие "Pan Camera" (Рисунок 2)
Где Player - Игрок, для которого нужно изменить положение камеры
Где Point - Точка/Центр области, в который нужно переместить камеру
Где Duration - Время, в течение которого это будет сделано

Вариант 1: Мгновенно
При таком варианте, при старте карты, камера будет сразу расположена на позиции, которую мы укажем
Где Point - Укажите "Значение - Ваша точка" (Рисунок 3)
Где Duration - Укажите "0" (Рисунок 4)

Вариант 2: Постепенно
При таком варианте, вы изменяете только параметр "Duration", на нужное вам время

Вариант 3: Позиция юнита, а не точки
При таком варианте, вы можете указать позицию юнита вместо точки
Для этого где "Point" укажите "Функция - Position Of Unit" (Рисунок 5)
Так же, теперь где "Triggering unit" измените на "Значение - Ваш юнит" (Рисунок 6)

Если у вас много юнитов, вы можете делать это гига удобным способом
В выборе значения, нажмите "Выбрать..." (Рисунок 7)
Он вам переключится на поверхность, на ней руками выберите юнита и нажмите "Q" (Рисунок 8)

Таким образом, вы сделаете все тоже самое, но гораздо удобнее

Вариант 4: Позиция центра области
При таком варианте, вы можете указать область, он сам определит центр этой области и переместит туда камеру
Где "Point" укажите "Функция - Center Of Region" (Рисунок 9)
Где он подсвечивает красным, укажите область и можете проверять</value>
            </setting>
            <setting name="Module2_Vopros16" serializeAs="String">
                <value>Измение начального положения камеры игрока</value>
            </setting>
            <setting name="Module2_Vopros17" serializeAs="String">
                <value>Как сделать звук и кружащие круги вокруг юнита, при передачи контроля над ним? </value>
            </setting>
            <setting name="Module2_Otvet17" serializeAs="String">
                <value>Это делается через триггеры и для примера, я создам простую карту (Рисунок 0, 1, 2 и 3)
Представим, что я хочу, чтобы игрок подошел к нейтральным юнитам и контроль над ними передался игроку
При этом это должна быть не просто смена владельца и цвета, а звук передачи + кружащие круги + смена владельца

На моем примере это будет выглядеть так:
Игрок входит в область "Owner 1/2/3" и все юниты, находящиеся в области "Units 1/2/3" будут переданы игроку

Заходим в Модуль Триггеров
Создадим новый триггер и в событие ему укажем "Unit Enters/Leaves Region" (Рисунок 4)

Теперь где "Entire Map" меняем на "Значение - Наша область" (Рисунок 5)
Это будет означать, что при входе любого юнита в область, этот триггер сработает

Теперь нужно указать условие, которое будет проверять, чтобы в область вошел юнит игрока 1
Выбираем условия и создаем новый элемент(Ctrl + W)
По умолчанию там всегда "Сравнение" + "Проверка владельца юнита" и просто сразу жмем ОК (Рисунок 6)

Теперь переходим к действиям и создадим для начала действие, которое будет исключать повторения
Создаем действие "Turn Trigger On/Off" и оставляем все параметры без изменений (Рисунок 7)

Создаем действие "Pick Each Unit In Unit Group" (Рисунок 8)
Где "Unit Group" - Меняем "Units In Region Matching Condition" (Рисунок 9)

Теперь: 
Где Region - Меняем на "Значение - Ваша область» (Область, в которой находятся юниты, которых нужно передать игроку) (Рисунок 10)
Где Player - Меняем на "Значение" и указываем номер игрока, для которого вы разместили юнитов (В моем случае это игрок 0 - нейтральный) (Рисунок 11)
Где Unit Filter - Оставляем без изменений, если вам нужны все юниты этого игрока в области. Исключением будет только если вам нужны только строения/только наземный/только воздушный (Рисунок 12)
Где Count - Оставляем без изменений, если вам нужно любое количество юнитов

Это мы сделали поиск юнитов в области, по определенным фильтрам, + так как мы используем это в "Pick Each Unit In Unit Group", то мы сразу можем так сказать "перебрать/прогнать в цикле каждого юнита" и что-то с ними сделать

Далее в этом цикле создадим действие "Rescue Unit" (Рисунок 13)
Где "Unit" - Меняем на "Picked Unit" (Рисунок 14)

Так же сделаем задержку как в кампании
Создадим действие "Wait" и время укажем на 0.25 (Рисунок 15)

Дальше чтобы вам не повторять все предыдущие действия, вы можете буквально скопировать и вставить созданный триггер
Копируем его и изменяем:
В событии - Область входа игрока "Owner 1" на "Owner 2"
В действиях - Область смены владельца юнитов "Units 1" на "Units 2" (Рисунок 16)</value>
            </setting>
            <setting name="Module2_Otvet18" serializeAs="String">
                <value>Это делается через триггеры и для примера, я создам простую карту (Рисунок 0)
Так же вам нужно создать область, в которой хотите создать видимость для игрока
В моем примере у меня есть группа юнитов, поверх которых я сделал "Область 001", в которой я и буду создавать видимость для игрока

Заходим в Модуль Триггеров
Выбираем созданный по умолчанию триггер "Инициализация схватки"
Так как для меня это тестовая карта, то я удалю из него не нужные действия и буду создавать видимость прямо в этом триггере (Рисунок 1)

Создадим действие "Reveal Area" (Рисунок 2)
Где Area - Нужно указать область, в которой нужно создавать видимость (Рисунок 3)
Где Player - Указываете игрока, для кого создается видимость
Где Duration - Указываете время, в течение которого нужно создавать видимость
Если указать 0, то это будет значить "бесконечно"

В игре это будет выглядеть вот так (Рисунок 4)</value>
            </setting>
            <setting name="Module2_Vopros18" serializeAs="String">
                <value>Создание видимости определенной области для игрока</value>
            </setting>
            <setting name="Module2_Vopros19" serializeAs="String">
                <value>Как сделать так, чтобы КСМ/Рабочие/Зонды начали добывать ближайшие минералы?</value>
            </setting>
            <setting name="Module2_Vopros20" serializeAs="String">
                <value>Запуск следующей карты через триггеры</value>
            </setting>
            <setting name="Module2_Otvet20" serializeAs="String">
                <value>Для примера я сделал 2 разные карты
На первой карте игроку нужно будет пройти по дороге и встать на маяк (Рисунок 0)
После этого игрок перейдет на следующую карту

На второй карте игрок сможет найти поселение колонистов (Рисунок 1)
Это нужно для того, чтобы можно было наглядно увидеть, что это 2 разные карты
Так же вам нужно будет опубликовать обе карты для возможности перехода + вы должны быть автором этих карт

Заходим в Модуль Триггеров
Создадим новый триггер и в событие ему укажем "Unit Enters/Leaves Region" (Рисунок 2)

Теперь где "Entire Map" меняем на "Значение - Наша область" (Рисунок 3)
Это будет означать, что при входе любого юнита в область, этот триггер сработает

Теперь нужно указать условие, которое будет проверять, чтобы в область вошел юнит игрока 1
Выбираем условия и создаем новый элемент(Ctrl + W)
По умолчанию там всегда "Сравнение" + "Проверка владельца юнита" и просто сразу жмем ОК (Рисунок 4)

Теперь переходим к действиям и создадим для начала действие, которое будет исключать повторения
Создаем действие "Turn Trigger On/Off" и оставляем все параметры без изменений (Рисунок 5)

Дальше я сделаю исчезновение маяка и задержку перед переходом просто для красоты
Если у вас переход будет осуществляться по-другому, то пропустите этот шаг

Создадим действие "Kill Unit" (Рисунок 6)
Где Unit - Изменим на "Значение - и укажем наш маяк" (Рисунок 7)

Создадим действие "Wait" и укажем условно 5 секунд (Рисунок 8)

Последним нужно создать действие "Online Map To Map Load" (Рисунок 9)
Теперь разберемся что тут и как:
Map Slot - Тут нужно указать слот карты, который мы настроем чуть дальше
Victory Plyers - По умолчанию стоит "Все игроки" и это значит, что все игроки получат результат игры "Победа"
Defeat Players - По умолчанию стоит "Пустая группа игроков" и это значит, что никто из  игроков не получит "Поражение"

Если вы откроете Victory или Defeat, то увидите множество альтернативных вариантов (Рисунок 10):
1) Активные игроки - Все игроки, находящиеся в игре
2) Союзники/Противники игрока
3) Конкретный номер игрока
4) Игроки в команде
5) Использование переменной, в которую можно добавлять определенных игроков, для которых вы хотите выдать победу или поражение

Я оставлю без изменений, и просто буду запускать следующую карту

Теперь посмотрим, как настроить слоты под карты (Перед этим шагом опубликуйте обе карты)
На верхней панели нажимаем "Файл - Управление опубликованными материалами" (Рисунок 11)

В открывшемся окне войдите в сеть под своим аккаунтом 
После авторизации у вас появится список опубликованных вами карт
Для примера я назвал свои карты "Переход карт 1" и "Переход карт 2" 
Выбираем карту, на которую будет переход (в моем случае это "Переход карт 2") и наводимся на "Assign Map Slot"
Там появится выпадающий список, в котором будет тоже "Assign Map Slot" (Рисунок 12)

Указывайте любой свободный слот
После этого в списке можно будет увидеть, что этой карте указан определенный слот (Рисунок 13)

В игре это будет выглядеть так (Рисунок 14, 15, 16 и 17)</value>
            </setting>
            <setting name="Module3_Vopros13" serializeAs="String">
                <value>Дополнительные мутации личинок</value>
            </setting>
            <setting name="Module3_Otvet13" serializeAs="String">
                <value>Стандартная панель мутации личинок выглядит так (Рисунок 0)
Представим, что мы хотим добавить возможность мутации в "Бруталиска" и "Аберрацию" (Рисунок 1)

//
Для этого нам понадобится только добавить юнитов в способность личинок и указать кнопки на панели приказов
Учтите, что для личинки Blizzard уже сами все настроили, и вам надо только добавить юнитов
Для мутации любого юнита, не являющегося личинкой, вам нужно делать "способность трансформации"
Эта способность уже отдельная тема, так как там еще и агент юнита нужно будет настраивать
Я как-нибудь потом это добавлю тоже
//

Заходим в Модуль Данных и переходим во вкладку "Способности"
Находим там способность "Личинка - Morph Unit (Larva -&gt; Basic)" (Рисунок 2)

Находим поле "Информация+" и открываем его (Рисунок 3)

В появившемся окне видим список всех юнитов, в которых может мутировать личинка
Сделайте двойной клик по любому свободному слоту, чтобы открыть его
Для примера, я буду использовать слоты 20 и 21 (Рисунок 4)

В появившемся окне видим всевозможные настройки
Начнем сверху вниз, указывая значения полей по порядку
1)"Информация - Кнопка - Кнопка по умолчанию" нажмите "Выбрать" и укажите какую-нибудь кнопку
Лучше для каждого юнита, в способности и на панели приказов указать одинаковые кнопки, просто для вашего же удобства (Рисунок 5)

2) "Информация - Кнопка - Требования" пока можно пропустить
Тут можно указать какое-нибудь требование, которое будет запрещать эту мутацию, пока игрок не выполнит определенное условие
Например, построит "Омут рождения"

3) "Информация - Технология - затрачиваемые ресурсы" тут вы можете указать стоимость мутации (Рисунок 6)
Учтите, что если в самом юните тоже указана стоимость, то они будут складываться 
Я тут тоже ничего не буду указывать

4) "Информация - Заряд"
Это позволяет без требований сделать использование этой способности определенное кол-во раз (Рисунок 7)
Так же можно сделать, чтобы новые заряды появлялись через определенное время 

5) "Информация - Время"
Это время обучения/строительства юнита (Рисунок 8)
Укажем, к примеру, 10 секунд

6) "Информация - Единица"
Тут как раз и указывается юнит, в которого нужно мутировать (Рисунок 9)
Нажмите на зеленый плюс (Рисунок 10) и у вас откроется еще одно окно, в котором нужно будет указать юнита (Рисунок 11 и 12)

Готово, теперь просто нажмите ОК (Рисунок 13)
По такому же принципу добавьте "Бруталиска" и получится что-то такое (Рисунок 14)
Только у "Бруталиска" нет подходящей кнопки, и я указал рандомную
Вы можете создать свою кнопку или использовать тоже другую

Все, в этом окне тоже нажимайте ОК
Теперь перейдите во вкладку "Единицы"
Найдите там "Личинка" и найдите у нее поле "Панель приказов" (Рисунок 15)

Открыв панель приказов, вы увидите кнопки, которые вы можете видеть в игре (Рисунок 16)
Теперь добавим 2 новые кнопки, которые будут отвечать за наши новые мутации
Нажмите в любой пустой слот и нажмите на зеленый плюс (Рисунок 17)

Добавив кнопку, видим, что у нее тип "Неопределенный" (Рисунок 18)
Его нужно поменять на "Команда способности" и указать способность личинки (Рисунок 19 и 20)

Теперь надо выбрать только нужное нам "Обучение"
Для этого я говорил, что надо указывать кнопки одинаковые для удобства
Открываем список и указываем "Породить аберрацию" (Рисунок 21)

Делаем тоже самое для "Бруталиска" и нажимаем ОК (Рисунок 22)

Теперь можем запустить игру и увидеть новые кнопки (Рисунок 23)
Таким образом, личинка сможет мутировать в "Аберрацию" и "Бруталиска" (Рисунок 24, 25, 26 и 27)</value>
            </setting>
            <setting name="Module1_Vopros4" serializeAs="String">
                <value>Как изменить количество ресурсов в минералах/веспене?</value>
            </setting>
            <setting name="Module1_Otvet4" serializeAs="String">
                <value>Чтобы изменить количество ресурсов, вам нужно выделить их и нажать "Enter" (Рисунок 0)
Перейти во вкладку "Ресурсы" и указать нужное количество ресурсов (Рисунок 1)

Вы можете указывать, сколько будет ресурсов для каждой отдельной сложности ИИ (Рисунок 2)
Для веспеновых гейзеров все тоже самое</value>
            </setting>
            <setting name="Module3_Vopros14" serializeAs="String">
                <value>Смена иконки ресурса</value>
            </setting>
            <setting name="Module3_Otvet14" serializeAs="String">
                <value>Чтобы изменить иконку ресурса, вам нужно зайти в Модуль Данных
Открыть там вкладку "Данные игрового интерфейса" (Рисунок 0)

Выбрать "Default SC2 UI Settings" (Рисунок 1)
Пролистать внизу и найти поле "Ресурсы +" (Рисунок 2)

В открывшемся окне вы можете видеть все 4 ресурса
Вы можете менять Значок и Подсказку

Где поле "Значок" нужно указать значок с полным путем (Рисунок 3)
Если вы не знаете где его взять, нажмите "Отмена" и перейдите во вкладку "Кнопки" (Рисунок 4)
Выберите любую понравившуюся кнопку, и откройте у нее поле "Значок" (Рисунок 5 и 6)

Выберите нужную иконку, нажмите по ней ПКМ и нажмите "Копировать" (Рисунок 7)
Таким образом, вы скопировали название значка вместе с полным путем к нему

Теперь вернитесь обратно в "Данные игрового интерфейса" и в поле "Значок" вставьте скопированный текст (Рисунок 8)

Запустив игру, вы можете увидеть, что значок минералов сменился (Рисунок 9)</value>
            </setting>
            <setting name="Module2_Vopros21" serializeAs="String">
                <value>Как сделать задачи?</value>
            </setting>
            <setting name="Module2_Otvet21" serializeAs="String">
                <value>Задачи делаются через триггеры
Рассмотрим такой вариант:
У меня есть командный центр и несколько КСМ (Рисунок 0)
Я хочу сделать 2 задачи, которые будут требовать добыть несколько минералов и веспена
Так же, еще одну задачу, которая будет требовать, чтобы командный центр уцелел

Разделим их на основным и дополнительные
Добыча ресурсов будет дополнительные, а командный центр будет основная

Заходим в Модуль Триггеров
Выбираем созданный по умолчанию триггер "Инициализация схватки"
Так как для меня это тестовая карта, то я удалю из него не нужные действия (Рисунок 1)

Для того чтобы обновлять задачи из других триггеров, вам нужно будет создать для них переменные
Создадим первую переменную "Objective Minerals" (Рисунок 2)
Поменяем ей тип с "Целое число" на "Задача" (Рисунок 3)
Эта переменная будет означать нашу задачу по сбору минералов

Скопируем ее и изменим название на "Objective Vespene"
Скопируем ее еще раз и изменим название на "Objective CommandCenter"
В итоге у нас получится 3 переменные (Рисунок 4)

Вернемся в "Инициализация схватки"
Создадим действие "Create Objective" (Рисунок 5)

Посмотрим, какие параметры имеет это действие: (Рисунок 6)
State - Означает текущий статус задачи: Активное/Выполненное/Проваленное/Скрытое
Type - Означает какой это тип задачи: Основная/второстепенная
Text - Текст, который будет написан в задании
Description - Описание задачи, которое можно прочитать, наведя курсор на него
(В конце будет скриншот со всеми параметрами)

Первая моя задача будет Активной, Основной и иметь текст "Командный центр должен уцелеть"
Оставляю все параметры без изменений, а меняю только текст (Рисунок 7)

Сразу после создаю действие "Set Variable" (Рисунок 8)
Где Variable - Указываем переменную, которая отвечает за нашу основную задачу "Objective CommandCenter" (Рисунок 9)
Где Value - Меняем на "Функция" и указываем "Last Created Objective" (Рисунок 10)

Запустив игру, мы можем увидеть, что появилась наша основная задача (Рисунок 11)

Теперь создадим еще 2 задачи для ресурсов
Чтобы нам было проще на это смотреть, разделим их комментарием (Рисунок 12)
Скопируем и вставим 2 предыдущих действия (Рисунок 13)

Выбираем действие "Create Objective" и меняем в нем:
Type - Primary на Secondary (Рисунок 14)
Text - Меняем наш текст на "Добыть 1000 минералов" (Рисунок 15)

Теперь выбираем следующее действие "Set Variable" и меняем в нем:
Variable - "Objective CommandCenter" на "Objective Minerals" (Рисунок 16)

Таким образом, мы без лишних телодвижений, сделали еще одну задачу и сразу записали ее в переменную
Запустив игру, видим, что появилась еще одна задача (Рисунок 17)

Сделайте то же самое для задачи с веспеном, чтобы получилось вот так (Рисунок 18 и 19)

Далее создадим триггер, который будет выполнять наши задачи
Создаем новый триггер (Рисунок 20)

В событиях у него создаем "Player Property Changed" (Рисунок 21)
По умолчанию там "Minerals"
Копируем это событие и меняем "Minerals" на "Vespene" (Рисунок 22)

Таким образом, наш триггер будет срабатывать на изменение ресурсов игрока
Переходим к действиям и создадим там "If Then Else" (Рисунок 23)
Теперь где "If" - нажимаем Ctrl + W и сразу нажимаем ОК (Рисунок 24)

Это мы создали условие, которое сейчас настроим как нам надо
Где value 1 - Меняем на "Player Property" (Рисунок 25)
Где Operator - Меняем на "=&gt;" (Больше или равно)
Где value 2 - Меняем на 1000 (Рисунок 26)

Условие настроено, теперь создадим действие, которое будет выполнять нашу задачу
Переходим к "Then" и создаем там действие "Set Objective State" (Рисунок 27)
Где Objective - Меняем на "Переменная" и указываем переменную "Objective Minerals" (Рисунок 28)

Выполнение задачи на минералы настроено
Можете скопировать и вставить весь If Then Else
Поменять минералы на веспен и получится что-то такое (Рисунок 29)

Таким образом, если накопится 1000 или более минералов, задача на минералы выполнится (Рисунок 30)
То же самое и с веспеном

Сделаем еще проверку, если задачи на ресурсы выполнены, то основное задание тоже выполнится
Создадим еще один If Then Else в этом же триггере
Создадим точно так же условие и нажмем ОК

Теперь где value 1 - Меняем на "Objective State" (Рисунок 31)
Где Objective - Меняем на "Переменная" и указываем нашу переменную "Objective Minerals" (Рисунок 32)
Где Value 2 - Меняем на "Предустановка" и указываем "Completed" (Рисунок 33)

Скопируем условие и "Objective Minerals" изменим на "Objective Vespene" (Рисунок 34)
Скопируем действие "Set Objective State" и где "Objective" изменим на "Objective CommandCenter" (Рисунок 35)

Все готово, теперь можно запустить и увидеть, что когда ресурсы собраны, все задачи выполняются (Рисунок 36)

А теперь что тут можно улучшить/изменить:
1) У нас в задаче не пишется, сколько ресурсов собрано из скольки
То есть 100/1000
Это можно изменить следующим образом:
При создании задачи, вам нужно вместо текста указать "Функция" - "Combine Text Multiple" (Рисунок 37)
Потом добавлять новые элементы (Рисунок 38) чтобы было вот так (Рисунок 39)

Где пустой текст нужно будет указать ресурсы игрока
Для этого открываем, меняем "Значение" на "Функция" и указываем "Convert Integer To Text" (Рисунок 40)
Далее, где value - Меняем на "Функция" - "Player Property" (Рисунок 41)
После, где Player - Укажите любого игрока
Можете сделать то же самое с веспеном

И последнее, теперь надо сделать то же самое для триггера, в котом мы выполняем задачи
Перейдем к нему и для "If Then Else", где "Else", создадим действие "set objective text" (Рисунок 42)
Где objective - Меняем на нашу переменную "Objective Minerals"
Где Text - Тут можно сделать 2 клика
Вернитесь в место, где вы создавали задачи и выберите задачу с минералами
Теперь нажмите 1 раз на вот этот вот "Combine Text Multiple" и скопируйте его (Ctrl + C) (Рисунок 43)

После этого вернитесь в триггер, где мы выполняем задачи, выберите созданное действие "Set Objective Text"
Где Text - Нажмите 1 раз и вставьте скопированное ранее (Рисунок 44)
Теперь при добыче минералов, будет писаться не только, сколько их нужно собрать, но и текущее значение (Рисунок 45)

2) В моем примере я создавал задачи, которые видны всем игрокам сразу, а так же рассчитаны на одного игрока
В этом примере, моя цель была просто показать, как их создавать/менять статус/менять тип задачи/менять текст
Если вам нужны задачи для каждого игрока отдельные, то это обширная тема и на это лучше сделать видео</value>
            </setting>
            <setting name="Module2_Vopros22" serializeAs="String">
                <value>Создание Boss Bar</value>
            </setting>
            <setting name="Module2_Otvet22" serializeAs="String">
                <value>Заходим в Модуль Триггеров
Выбираем созданный по умолчанию триггер "Инициализация схватки"
Так как для меня это тестовая карта, то я удалю из него не нужные действия (Рисунок 0)

Тут можно сделать 2 способами:
Первый способ - это когда у вас юнит, отвечающий за "Босса" сразу размещен на карте
Второй способ - это когда у вас юнит, отвечающий за "Босса" не замещен на карте, и вы создаете его в процессе игры

Для начала я покажу, как сделать вторым способом, так как это дольше настраивать

Создадим действие "Create Units Facing Angle" (Рисунок 1)
Где Type - указывайте вашего юнита, который будет "Боссом"
Где Player - указывайте игрока, которому будет принадлежать "Босс" (Например, игрок 15)
Где Point - указывайте точку, где босс появится (В моем случае это будет центр карты)

Теперь нужно создать переменную, которая будет отвечать за вашего босса
В триггерах, в свободном месте нажмите ПКМ - наведите на "Создать" - нажмите "Создать переменную" (Рисунок 2)
Для примера назовем ее "Boss Unit"

Теперь нужно менять ей тип с "Целое число" на "Единица" (Рисунок 3)

Теперь вернитесь обратно в триггер "Инициализация схватки"
Создайте новое действие "Set Variable" (Рисунок 4)
Где Variable - укажите созданную ранее переменную "Boss Unit" 
Где Value - укажите "Функция" - "Last Created Unit" (Рисунок 5)

Далее уже можно будет создать сам Boss Bar
Создадим новое действие "Display Boss Bar"  (Рисунок 6)
Где BossBarID - Номер, к которому он будет принадлежать (Оставим по умолчанию)
Этот ID позволяет создавать несколько BossBar, и обращаться к ним по номеру ID

Где Title - Отображаемое имя "Босса" (Я оставлю по умолчанию, но вы можете менять)
Если вам нужно чтобы имя определялось само, то в самом конце, где варианты изменения, я покажу, как это сделать

Где Portrait - Иконка, отображаемая рядом со здоровьем (Можно менять)

Создание завершено, теперь нужно указать максимальное + текущее значение
Создадим новое действие "set boss bar maximum value" (Рисунок 7)
Где BossBarID - Оставяем без изменений, так как у нас только один BossBar
Где Max - Переключите на "Функция" и выберите "Unit Property (Int)" (Рисунок 8)

В unit property, где "Единица" - поменяйте на "Last Created Unit" (Рисунок 9)
Где "Свойство" - поменяйте на "Maximum Life" (Рисунок 10)
Таким образом, игра сама будет определять максимальное значение для BossBar, основываясь на максимальном здоровье юнита

Теперь сделаем тоже самое для текущего значения
Создадим новое действие "set boss bar current value" (Рисунок 11)
Где Current - Переключите на "Функция" и выберите "Unit Property (Int)"
Сделайте по аналогии с максимальным значением, только "Maximum Life" поменяйте на "Life" (Рисунок 12)

Таким образом, мы сделали создание BossBar, для которого будет автоматически выставляться значение здоровья

Теперь нужно сделать обновление его значения при изменении здоровья "Босса"
Это нужно для того, чтобы при любом изменении его здоровья, будь то регенерация или получения урона, значение BossBar тоже менялось

Создадим новый триггер (Ctrl + T) и назовем его, к примеру "Boss Life Change"(Рисунок 13)
Дважды кликните по "Evetns" и укажите там событие "Unit property changes" (Рисунок 14)
Где Unit - Переключите на "Переменная" и укажите нашу переменную "Boss Unit" (Рисунок 15)
Это событие будет срабатывать на любое изменение здоровье "Босса"

Теперь нужно просто снова менять текущее значение BossBar, на значение текущего здоровья "Босса"
Вернитесь в прошлый триггер, скопируйте действие "Set Boss Bar Current Value" и перенесите его в новый триггер "Boss Life Change" (Рисунок 16 и 17)

Далее в Unit Property (Int) нужно поменять:
Где Единица - Переключите на "Переменная" и укажите переменную "Boss Unit" (Рисунок 18)

Осталось лишь создать триггер, который будет скрывать BossBar, когда "Босс" погибает

Создадим новый триггер и назовем его, к примеру "Boss Die"
Дважды кликните по "Evetns" и укажите там событие "Unit Dies" (Рисунок 19)
Где Unit - Переключите на "Переменная" и укажите нашу переменную "Boss Unit" (Рисунок 20)

Далее в Actions создайте действие "Show/Hide Boss Bar" (Рисунок 21)
Где Show/Hide - Поменяйте на Hide (Рисунок 22)

Теперь создайте действие "trigger on/off" и оставьте все параметры по умолчанию (Рисунок 23)
Это действие будет отключать данный триггер после смерти "Босса"

Скопируйте и вставьте сюда же это действие
Поменяйте "Current Trigger", переключив на "Значение" и выберите "Boss Life Change" (Рисунок 24)
Это сразу такая мини-опитимазиция триггеров

Все, теперь все готово.

Теперь рассмотрим варианты изменения:
1) Когда "Босс" сразу есть на карте, вы можете не создавать переменную для него, а просто вручную везде его указывать
Выглядеть это будет вот так: представим ситуацию, когда "Осадный танк" будет, является "Боссом" у меня на карте + он сразу будет на ней размещен

В начальном триггере, где я создавал "Босса", удалим действие "Create Units Facing Angle" и "Set Variable" (Рисунок 25)
В действии "Set Boss Bar Maximum Value" и "Set Boss Bar Current Value", поменяем "Last Created Unit" на "Значение", и укажем нашего юнита (Рисунок 26)

Перейдем в триггер "Boss Life Change" и сделаем тоже самое с событием и действием, находящимися в этом триггере (Рисунок 27)

Перейдем в триггер "Boss Die" и сделаем тоже самое с событием, находящимся в этом триггере (Рисунок 28)
После этого переменную "Boss Unit" можно вообще удалить

2) Автоматическое определение имени "Босса"
Перейдем в начальный триггер, где мы только создаем BossBar и выберем действие "Display Boss Bar"
У этого действия, где "Title" - нужно поменять на "Функция" и указать "Name Of Unit" (Рисунок 29)

Где Unit - Укажите вашего юнита или переменную Boss Unit (Рисунок 30)
Где Portrait - Отваливается иконка, поэтому просто укажите ее еще раз</value>
            </setting>
            <setting name="Module1_Otvet5" serializeAs="String">
                <value>Если у вас выделение стало ромбиком вместо прямоугольника (Рисунок 0), то просто на верхней панели нажмите "Инструменты" и снимите галку с "Диагональное выделение" (Рисунок 1 и 2)</value>
            </setting>
            <setting name="Module1_Vopros5" serializeAs="String">
                <value>Как вернуть выделение прямоугольником?</value>
            </setting>
            <setting name="Module3_Vopros15" serializeAs="String">
                <value>Схема по созданию своих юнитов для новичков</value>
            </setting>
            <setting name="Module3_Otvet15" serializeAs="String">
                <value>https://miro.com/app/board/uXjVNzc2wYs=/</value>
            </setting>
            <setting name="Module2_Vopros23" serializeAs="String">
                <value>Измение описания кнопки триггерами</value>
            </setting>
            <setting name="Module2_Otvet23" serializeAs="String">
                <value>Триггерами можно менять описание определенной кнопки у определенного юнита
Для примера возьмем несколько юнитов и изменим им реген здоровья (Рисунок 0)

Далее вам нужно всем этим юнитам добавить на панель приказов кнопку, описание которой мы будем менять
Я, в качестве примера, буду менять описание кнопки движения

Заходим в Триггеры
Создаем новый триггер

В событиях указываем - "Unit Enters/Leaves Region" (Рисунок 1)
Параметры события оставляем без изменений и сразу переходим к действиям

В действиях создаем "set unit info button - button tooltip" (Рисунок 2 и 3)
В этом действии, нам нужно указать:
1) У какого юнита будем менять описание
2) Описание какой кнопки будем менять
3) Текст, который будет заменять старый 
(Рисунок 4)

Вместо «Last created unit» указываем - Triggering Unit (Рисунок 5)
Вместо «No Game Link» указываем - Наша кнопка (Рисунок 6)
Вместо «Текст» указываем - Наш текст, но в моем случае, это будет combine text (Рисунок 7)

В Text1 указываем - "Regen: " (Рисунок 8)
В Text2 указываем - "Covent Real To Text (Adavanced)" (Рисунок 9 и 10)

В Value указываем - "Unit Proprety" (Рисунок 11)
Где Proprety: Life меняем на - "Life regeneration Rate" (Рисунок 12)
Где Current меняем на - "Default" (Рисунок 13)

В итоге получаем кнопку, в которой указан базовый реген для каждого юнита
(Рисунок 14, 15, 16 и 17)</value>
            </setting>
            <setting name="Module2_Vopros24" serializeAs="String">
                <value>Таймеры - запуск и событие окончания</value>
            </setting>
            <setting name="Module2_Vopros25" serializeAs="String">
                <value>Условие проверки "Убивающего игрока"</value>
            </setting>
            <setting name="Module2_Otvet25" serializeAs="String">
                <value>Значение "Убивающего игрока" можно проверить условием или получить для переменной

Будем использовать такой пример:
У нас имеются 1 танк и 1 морпех для двух игроков (Рисунок 0)

Начнем с условия:
Создадим новый триггер и в события укажем "Unit Dies" (Рисунок 1)
Это событие срабатывает на смерть любого юнита

Создадим условие "if then else" (Рисунок 2)
Где if - Создаем новый элемент и оставляем по умолчанию(сравнение)(Рисунок 3)
Где Value 1 - Меняем на "Killing Player" (Рисунок 4)
Где Value 2 - Теперь означает номер игрока, который совершает убийство юнита

В "Then" создадим текстовое сообщение для проверки (Рисунок 5)
Еще для теста сделаем игрока 1 и игрока 2 союзниками, чтобы мы могли это нормально проверить

Как видим, теперь, когда игрок 1 убивает марина, в чат выводится сообщение (Рисунок 6)
А если это делает игрок 2, то ничего не происходит (Рисунок 7)

Получение значение убивающего игрока для переменной:
Создадим локальную переменную "Player" с типом "Целое число" (Рисунок 8)

В самом начале действий создадим "Set Variable" (Выбирается по умолчанию, сразу можно нажимать enter)
Где Variable - Укажем нашу переменную "Player" (Рисунок 9)
Где Value - Укажем "Killing Player" (Рисунок 10)

Таким образом, мы можем проверять или использовать нашу переменную</value>
            </setting>
            <setting name="Module2_Vopros26" serializeAs="String">
                <value>Следование камеры за юнитом</value>
            </setting>
            <setting name="Module2_Otvet26" serializeAs="String">
                <value>Чтобы включить следование камеры за юнитом, нужно использовать действие "Follow Unit Group with Camera" (Рисунок 0)
Где Follow - Означает, нужно ли в данный момент включить или отключить следование (По умолчанию включить)
Где Player - Означает, камера какого игрока будет следовать
Где Unit Group - Означает, за какой группой юнитов будет следовать камера

Чтобы указать конкретного юнита, нам нужно "Last Created Units" поменять на "Convert Unit To Unit Group" (Рисунок 1)
Вместо "Triggering Unit" указываем "Значение" и выбираем нужного юнита (Рисунок 2)</value>
            </setting>
            <setting name="Module2_Vopros27" serializeAs="String">
                <value>Событие выбора юнита</value>
            </setting>
            <setting name="Module2_Otvet27" serializeAs="String">
                <value>Чтобы отследить выбор юнита игроком, нужно использовать событие "Unit Is Selected" (Рисунок 0)
Где Unit - Указано "Любой Юнит"
Это значение можно изменить на:
1) Размещенного на карте юнита
2) Юнита из переменной

Если нужно, чтобы триггер срабатывал на какой-то определенный тип юнитов или юнитов определенного игрока, то оставляйте Any Unit

Selected/Deselected - Означает, на что именно будет срабатывать событие
По умолчанию указано "Selected" и событие будет срабывать именно на выбор юнита
Можно поменять на "Deselected" и событие будет срабатывать, когда выбирается любой другой юнит

Player - Означает, какой игрок должен выбирать юнитов, чтобы срабатывало событие

Вариант триггера 1: определенный тип юнитов
Оставляем событие по умолчанию и переходим к условиям триггера
Создаем условие сравнения(по умолчанию)
Где Value 1 - Указываем "Unit type of unit" (Рисунок 1)
Где Value 2 - Указываем нужный тип юнита (например, морпех)

Добавим текстовое сообщение для проверки нашего триггера (Рисунок 2)
Теперь выбирая морпеха будет появляться сообщение о том, что юнит был выбран (Рисунок 3)

Вариант триггера 2: Юнит из переменной
Создадим глобальную переменную с типом "Единица" (Рисунок 4)
Создадим действие, которое будет спавнить нам мародера при старте карты, используя "Create units facing angle" (Рисунок 5)
Укажем юнита и точку (Рисунок 6)

Теперь запишем созданного юнита в переменную, используя "Set Variable"(Действие по умолчанию)
Где Variable - Укажем нашу переменную (Рисунок 7)
Где Value - Укажем "Last Created Unit" (Рисунок 8)

Вернемя в наш триггер с выбором юнита и изменим его:
1) В событии, вместо "Any Unit" укажем нашу переменную (Рисунок 9)
2) В условии, где "Value 1", вместо "Unit type of unit" укажем нашу переменную (Рисунок 10)
3) В условии, где "Value 2", укажем "No Unit" (Рисунок 11)
4) В условии, где "Operator", укажем "!=" (Рисунок 12)</value>
            </setting>
            <setting name="Module10_Vopros1" serializeAs="String">
                <value>Включение/Отключение ошибок в игре</value>
            </setting>
            <setting name="Module10_Otvet1" serializeAs="String">
                <value>Чтобы включить или отключить отображение ошибок во время игры, нужно зайти в настройки карты (Рисунок 0)
В этом разделе необходимо прокрутить список вниз и установить галочку на опции 'Прятать ошибки во время пробного запуска' (Рисунок 1)</value>
            </setting>
            <setting name="Module2_Vopros28" serializeAs="String">
                <value>Действие смены владельца юнита</value>
            </setting>
            <setting name="Module2_Otvet28" serializeAs="String">
                <value>Чтобы сменить сменить владельца юнита, можно использовать действие "Change Owner" (Рисунок 0)
Где Unit - Нужно указать юнита
Где Player - Новый владелец юнита
Где Color Change - Менять или сохранять цвет при смене владельца
(Рисунок 1)

Юнита можно указывать из "Значения", переменной или функции
По умолчанию указано "Triggering Unit", что означает запускающий юнит</value>
            </setting>
            <setting name="Module2_Vopros29" serializeAs="String">
                <value>Переключие видимости некоторых объектов на поверхности</value>
            </setting>
            <setting name="Module2_Otvet29" serializeAs="String">
                <value>Вы можете переключить видимость некоторых объектов на поверхности (Рисунок 0)

Для этого на верхней панели нужно выбрать "Вид" - "Пазакать слой" (Рисунок 1)
В этой вкладке можно отключать нужные вам объекты (Рисунок 2 и 3)

Даже если у вас выключено отображение каких-либо объектов, то в переходе на этот модуль, они будут отображаться
Например, если отключить видимость декораций, то зайдя в модуль декора, они будут видны, пока вы не переключите модуль</value>
            </setting>
            <setting name="Module2_Vopros30" serializeAs="String">
                <value>Совместное строительство для КСМ</value>
            </setting>
            <setting name="Module2_Otvet30" serializeAs="String">
                <value>Чтобы включить совместное строительство для КСМ, можно разработать улучшение "Story Mode Tech - (SCV) Ускоренное строительство"

Вы можете выдать игроку это улучшение триггерами или при помощи данных
Триггеры:
1) При помощи "Set Upgrade Level For Player" (Рисунок 0)
2) При помощи "Add Upgrade Level For Player" (Рисунок 1)</value>
            </setting>
            <setting name="Module3_Vopros16" serializeAs="String">
                <value>Увеличение сбора ресурсов рабочими</value>
            </setting>
            <setting name="Module3_Otvet16" serializeAs="String">
                <value>Чтобы изменить количество добываемых минералов, нужно найти найти алгоритм "MineralFieldMinerals"
Проще всего это сделать, выбрав нужно Месторождение минералов и перейдя к нужному алгоритму
Учитывайте, что для разных минералов, используются разные алгоритмы (Рисунок 0, 1 и 2)

В нужном алгоритме, измените поле "Количество добытых ресурсов" (Рисунок 3)
Теперь рабочие будут добывать по 100 минералов за раз (Рисунок 4 и 5)</value>
            </setting>
            <setting name="Module2_Vopros31" serializeAs="String">
                <value>Условие на проверку нахождения/отсутствия игрока в игре</value>
            </setting>
            <setting name="Module2_Otvet31" serializeAs="String">
                <value>Чтобы проверить наличие или отсутствие игрока в игре, вы можете использовать следующие условия:
1) Использовать "Controller of player" (Рисунок 0)
Где Player - Номер проверяемого игрока
Где Value 2 - Выбрать "User" (Рисунок 1)
Так же, можно проверять "Computer" или "None"

2) Использовать "Status of Player" (Рисунок 2)
Где Player - Номер проверяемого игрока
Где Value 2 - Выбрать "Playing" (Рисунок 3)</value>
            </setting>
            <setting name="Module3_Vopros17" serializeAs="String">
                <value>Автоприменение способности</value>
            </setting>
            <setting name="Module3_Otvet17" serializeAs="String">
                <value>Чтобы включить автоприменение способности, нужно зайти в эту способность и найти поле "Флаги" (Рисунок 0)
Во флагах нужно выставить галочки "Автоприменение" и "Автоприменение - всегда вкл." (Рисунок 1)

Автоприменение будет срабатывать при получении урона от врага (Рисунок 2 и 3)</value>
            </setting>
            <setting name="Module3_Vopros18" serializeAs="String">
                <value>Добавление заражения строениям</value>
            </setting>
            <setting name="Module3_Otvet18" serializeAs="String">
                <value>Чтобы добавить заражение строениям, нужно добавить определенное событие в агент строения
Для начала, можете зайти в агенты и выбрать один из существующих агентов, который будет добавлять заражение (Рисунок 0, 1 и 2)

После того, как вы выбрали нужный агент, возвращаемся к юниту, которому будем добавлять заражение
Например, будем использовать "Врата" и "Планетарная крепость" (Рисунок 3)

Находим этого юнита, переходим в его агент и октрываем поле "События" (Рисунок 4)
Добавляем новое событие, нажав ПКМ и выбрав "Добавить событие" (Рисунок 5)

Выбираем созданное событие и "Тип сообщения" меняем на "Создание агента" (Рисунок 6)
Выбираем привязанное к этому событию действие и "Тип сообщения" меняем на "Создать" (Рисунок 7)
Потом "По выбору" меняем на "Агент" (Рисунок 7)

Далее нажимаем "Выбрать" и выбираем нудный агент (Рисунок 8)
Теперь у Планетарной крепости будет заражение, но это строение слишком большое и заражение видно плохо (Рисунок 9)

Можем повторить тоже самое для Врат и получить такой результат (Рисунок 10)

Мы можем скопировать уже существующий агент заражения и изменить ему смещение
Вернемся в агенты и найдем, например, "Infestation Barracks" и продублируем его (Рисунок 11)

В данном случае, нам нужен только агент (Рисунок 12)
После дублирования, изменим название, дописав просто цифру 2

Теперь нужно создать агент, который будет отвечать за смещение
Создадим новый агент с типом "Локальная операция (локальное смещение)" 
Тип декорации указываем "Не декорация" (Рисунок 13)

Теперь сначала добавим наш созданный агент в дублированное заражение, а потом будем менять смещение
Выбираем наш дублированный агент заражения и находим поле "Запустить локальные операции +" (Рисунок 14)

Открыв это поле, нажмите на зеленый плюс и он добавит еще один агент (Рисунок 15)
Его нужно изменить на созданный ранее агент смещения (Рисунок 16)

Теперь мы можем менять смещение, подгоняя заражение под нужное строение
Но перед этим, нужно в агенте строения, поменять создаваемый агент заражения на новый (Рисунок 17)

Возвращаемся в созданный ранее агент смещения, находим поле "Локальное смещение" (Рисунок 18)
В случае с Планетарной крепостью, хватило задать смещение по Z на 1 ед. получив такой результат (Рисунок 19)

Так же, чтобы видить изменения смещения, достаточно просто удалять юнита с поверности и ставить его снова</value>
            </setting>
            <setting name="Module2_Vopros32" serializeAs="String">
                <value>Начало работы с модулем триггеров</value>
            </setting>
            <setting name="Module2_Otvet32" serializeAs="String">
                <value>Чтобы начать работать с триггерами, вам нужно ознакомиться с интерфейсом и некоторыми горячими клавишами

Начнем с настроек:
Это всего лишь один из вариантов отображения элементов в триггерах
Вы можете этого и не делать, но в ответах на вопросы я использую именно такой вариант

На верхней панели выбираем "Вид"
В этой вкладке нам нужны первые 4 галочки и автовыбор для групп (Рисунок 0)

На верхней панели выбираем "Окно"
В этой вкладке нам нужно указать "Панель инструментов" (Рисунок 1)

На панели инструментов, проверьте, чтобы эти кнопки были выбраны так же, как у меня (Рисунок 2)

Теперь рассмотрим, что и где отображается: (Рисунок 3)
Область под номером 1 - Это список всех созданных вами триггеров/переменных/функций и тд.
Область под номером 2 - Это список используемых библиотек (Библиотеки содержат набор функций/действий и тд.)
Область под номером 3 - Это окно выбранного элемента, в данном случае, это триггер (меняется в зависимости от выбранного элемента)
Область под номером 4 - Это окно, в котором отображается выбранный элемент и все используемые им элементы (переменные, кастомные функции/действия)
Область под номером 5 - Это окно, в котором отображается описание и параметры выбранного действия/события/условия
Область под номером 6 - Это окно групп, которое отображается, если сделать двойной клик по какому-либо элементу триггеров

Теперь рассмотрим, как что-либо создавать без использования горячих клавиш:
Вы можете в области, где находится список триггеров/переменных/функций нажать ПКМ и выбрать либо "Создать", либо "Библиотека" (Рисунок 4 и 5)
Кнопка "Создать элемент" создает элемент с таким же типом, который вы создавали в последний раз

Так же, вы можете использовать панель инструментов для создания элементов триггеров (Рисунок 6)


Теперь рассмотрим, как устроен триггер: (Рисунок 7)
Область под номером 1 - Это название триггера
Область под номером 2 - Это событие триггера
Область под номером 3 - Это локальные переменные триггера (есть глобальные, это те, что находятся в списке триггеров/переменных/функций)
Область под номером 4 - Это условия триггера
Область под номером 5 - Это список действий триггера
Область под номером 6 - Это параметры и описание выбранного в данный момент события/условия/переменной/действия триггера

Теперь разберем, как работает триггер:
Событие триггера - оно отвечает за то, при каком событии будет срабатывать этот триггер
Например, на скриншоте "Инициализация карты" и это означает, что триггер сработает, как только карта загрузится

Локальные переменные триггера - они позволяют временно хранить какие-либо значения с разными типами
Например, можно создать переменную, которая будет хранить "целое число", или будет указывать на какую-либо "Единицу" и тд.
Такие переменные хранят свое значение только в этом триггере и обновляются каждый раз, когда запускается триггер

Условия триггера - это набор правил, которые проверяются при запуске триггера
Если условия не будут равны "истина", то действия триггера не запустятся

Действия триггера - это набор команд, которые выполняются в ответ на определенные события игры
Например, они позволяют настраивать поведение юнитов, объектов и игровых механик

Параметры (Рисунок 8) - многие действия/события/условия требуют указать им какие-либо входные параметры для их выполнения

Теперь разберем, как создавать элементы внутри триггера:
Вы можете создавать элементы, основываясь на Рисунке 7 и использовать горячую клавишу "Ctrl + W"
Например, выбрав блок с событиями и нажав "Ctrl + W", вам будет предложено создать событие
Выбрав блок с условиями, вам будет предложено создать условие
Выбрав блок с переменными, вам будет предложено создать переменную
Выбрав блок с действиями, вам будет предложено создать действие</value>
            </setting>
            <setting name="Module3_Vopros19" serializeAs="String">
                <value>Способность трансформации юнитов(Зерги, не из личинки)</value>
            </setting>
            <setting name="Module3_Otvet19" serializeAs="String">
                <value>Чтобы сделать трансформацию из одного юнита в другого, нам нужно:
1) Создать способность
2) Настроить агент
3) Возможно настроить кокон трансформации

В данном примере, будем делать трансформацию Зерглинг =&gt; Заразитель
Создадим способность "MorphZerlingToInfestor" с типом "Обучение" (Рисунок 0)

Находим поле "Информация+" (Рисунок 1)
Открыв его, выбираем "Обучение 01" (Рисунок 2)

Указываем кнопку (Рисунок 3)
Указываем время, оповещение и тип единицы, в которую будет трансформация (Рисунок 4, 5 и 6)
Нажимаем везде ОК

Теперь находим поле "Трансформация боевой единицы" и указываем туда какой-нибудь кокон (Рисунок 7 и 8)
Тут есть сложность в том, что из некоторых коконов трансформация не получается и юнит начинает бесконечно сидеть в коконе
Исправить это можно тем, что просто выбрать другой кокон

Добавим созданную способность зерглингу (Рисунок 9 и 10)

На этом этапе можно запустить карту и проверить способность
Если при трансформации, вы видите, что старый юнит не удаляется и показывается такая ошибка (Рисунок 11 и 12)
То это значит, что нам дополнительно нужно настроить агент

Заходим в агент зерглинга и находим поле "События" (Рисунок 13)
В пустом месте жмем ПКМ и выбираем "Добавить событие" (Рисунок 14)

В созданном событии, "Тип сообщения" меняем на "Способность трансформации"
"Название источника" меняем на нашу способность
"Подназвание" меняем на "Начало" (Рисунок 15)

В прикрепленном к этому событию действии, "Тип сообщения" меняем на "Уничтожить" (Рисунок 16)
Теперь создадим условие к этому событию, нажав ПКМ по событию (Рисунок 17)

Созданное условие меняем на "MorphFrom" - "Зерглинг" (Рисунок 18)

Теперь нужно скопировать и вставить настроенное нами событие (Рисунок 19)
Прикрепленное действие "Уничтожить" меняем на "Проиграть анимацию" (Рисунок 20)
Нажав "Правка", в появившемся окне нажимаем TAB, и тогда появится возможность ввести название анимации (Рисунок 21)

Теперь мы можем выбрать нашу анимацию и указать ей свойства
Указываем "Трансформация" (Рисунок 22)

Остается настроить еще 2 события, которые будут работать на начало и на завершение трансформации
Скопируем первое событие, в котором действие "Уничтожить" (Рисунок 23)
Добавим условие, поменяем его на "AbilKey" и напишем туда "BurrowDown" (Рисунок 24)
Добавим условие, поменяем его на "MorphTo" и укажем и туда "Заразитель" (Рисунок 25)

Готовое событие копируем и вставляем (Рисунок 26)
Где "Подназвание" - "Начало" меняем на "Завершение" 
Где "AbilKey" меняем на "BurrowUp"
Где "Уничтожить" меняем на "Создать" (Рисунок 27)

Настройки готовы, теперь трансформация будет нормально работать
Есть еще некоторые проблемы, которые я не знаю, как исправить
Одна из них, это отсутствие модели у юнита при отмене способности
Исправить это можно тем, что запретить игрокам отменять трансформацию, пока она будет завершена

Чтобы это сделать, находим используемый кокон и находим у него поле "Флаги+"
В появившемся окне устанавливаем галочку "Команды неприменимы" (Рисунок 28)</value>
            </setting>
        </SC2MapEdtiorXeXxD.Properties.Settings>
        <SC2MapEdtiorXeX.Properties.Settings>
            <setting name="Module2_Otvet0" serializeAs="String">
                <value>Создаем новый триггер (Рисунок 1)
В нем создаем событие Chat Message (Рисунок 2)
Создав его, мы видим параметры, которое может принимать это событие (Рисунок 3)
Далее где Text: вписываете команду, на которую будет срабатывать триггер

Теперь создаем локальную переменную, называем ее Units (название может быть любым) и указываем ей тип "группа единиц" (Рисунок 4)
Создаем действие Set Varialbe (Рисунок 5)
Где Varible, указываем свою переменную Units (Рисунок 6)
Где Value, указываем: функция - Selected Units (Рисунок 7)
Где Player, указываем Triggering Player (Рисунок 8)

Далее создаем действие Pick Each Unit In Unit Group (Рисунок 9)
Где Unit Group, указываем нашу переменную Units (Рисунок 10)

Теперь тут же создаем действие If Then Else (Рисунок 11)
Где if создаем новый элемент(по умолчанию сравнение)(Ctrl + W) (Рисунок 12)
Где Value 1: Owner of Unit есть параметр Unit
В него указываем Picked Unit (Рисунок 13)
Где Value 2: Меняем на Triggering Player (Рисунок 14)
Далее в Then создаем действие Kill Unit (Рисунок 15)
Triggering Unit меняем на Picked Unit (Рисунок 16)

Готово.
Триггер на убийство юнитов при вводе команды чат готов.</value>
            </setting>
            <setting name="Module3_Vopros0" serializeAs="String">
                <value>Начало работы с модуем данных</value>
            </setting>
            <setting name="Module3_Vopros1" serializeAs="String">
                <value>Как сделать чтобы за убийство давались ресурсы?</value>
            </setting>
            <setting name="Module3_Otvet1" serializeAs="String">
                <value>Открыв вкладку "Единицы" найдите там юнита, за убийство которого будут даваться ресурсы.
Найдите поле "Уничтожить ресурс+" и открыв его, вы можете указать до 4х разных ресурсов.
Указывайте нужно количество и жмите ок.
Готово.</value>
            </setting>
            <setting name="Module3_Otvet0" serializeAs="String">
                <value>Для начала работы с модулем даныых, выставьте настройки таким образом (Рисунок 1)
Чтобы находить любые нужные данные, вы можете открывать и добавлять себе любые доступные вкладки (Рисунок 2)

Это нужно для того, чтобы при просмотре ответов на вопросы по модулю данных, у вас не возникали вопросы, с непониманием того, почему у меня что-то отображается, а у вас нет

Например, чтобы вы так же легко могли открыть агент любого юнита или любой другой объект, связанный с юнитом

Готово.</value>
            </setting>
            <setting name="Module2_Vopros0" serializeAs="String">
                <value>Как сделать убийство выбранного юнита при вводе команды в чат?</value>
            </setting>
            <setting name="Module2_Vopros1" serializeAs="String">
                <value>Какой ивент в триггерах делает что-бы после наступления определенного времени, происходило какое-нибудь действие?</value>
            </setting>
            <setting name="Module2_Otvet1" serializeAs="String">
                <value>За это отвечает событие "Time Elapsed" и "Periodic Event"
Находятся они по метке "Time" (Рисунок 1)

Вариант 1: Time Elapsed
Это событие отвечает за "Время прошло" и запускается один раз
Можно указывать время в секундах и тип времени (Рисунок 2)

Добавив вывод сообщения со временем миссии в чат, увидим такую картину (Рисунок 3)

Вариант 2: Periodic Event
Это событие отвечает за периодические события и запускается бесконечное кол-во раз
Так же можно указывать время в секундах и тип времени (Рисунок 4)

Добавив вывод сообщения со временем миссии в чат, увидим такую картину (Рисунок 5)

Готово.
Теперь вы знаете как это работает.</value>
            </setting>
            <setting name="Module2_Vopros2" serializeAs="String">
                <value>Как сделать подъем и спад лавы? + урон от лавы</value>
            </setting>
            <setting name="Module2_Otvet2" serializeAs="String">
                <value>Создадим простой рельеф для поднятия лавы (Рисунок 1)
Добавим лаву (Рисунок 2)
Откроем настройки воды (Рисунок 3)
Добавим новое состояние воды и сделаем цвет такой же как в "По умолчанию" 
Так же укажем нужну нам высоту для поднятой лавы. (Рисунок 4)
Зайдем в триггеры и создадим триггер, отвечающий за подъем и спад лавы. (Рисунок 5)
Создадим событие Pereodic Event и укажем время, через которое будет подниматься лава. (Рисунок 6)
Создадим устловие (If) (Рисунок 7)
Создадим глобальную переменную Lava Up/Down с типом "Булево" (Рисунок 8)
В условии будем проверять эту переменную со значением False (Рисунок 9)
В then создадим действие Play Sound и укажем туда звук TUIlavaRising (Рисунок 10)
Создадим действие Set Water State (Рисунок 11)
Где state укажем созданное ранее состояние воды (Рисунок 12)
Где over 1.0 secodns укажем 4 сек.
Далее создадим действие Wait для того, чтобы лава чисто визуально поднялась до нужного уровня,
ниже которого юниты будут получать урон. (Рисунок 13)
Далее создадим действие Turn Trigger On/Off
Где Off меняем на On
Current Trigger пока оставляем как есть (Рисунок 14)
После создадим действие Set Variable 
Где Variable укажем нашу переменную "Lava"
Где Value укажем "Истина" (Рисунок 15)

Теперь в Else скопируем действия:
Play Sound + Set Water State + Wait + Trigger On/Off + Set Variable (Рисунок 16)
Двух секундную задержку в действии Wait меняем на 1.5 сек.
В Set Variable "Истина" меняем на "Ложь", просто убрав галку(Рисунок 17)
В Set Water State меняем состояние на "По умолчанию" (Рисунок 18)
В Trigger On/Off параметр "On" меняем на "Off" (Рисунок 19)

Дальше нужно создать триггер, который будет наносить урон юнитам в лаве
Создадим триггер Lava Damage
Нажимаем на него ПКМ и убираем галку "Изначально включен" (Рисунок 20)
Добавим в него событие "Periodic Event" и установим параметр "Duration" на значение "0.5" (Рисунок 21)
Далее в условии триггера добавим условие(просто crtl + w + enter)
Где Value 1 укажем "Trigger Is On"
Где Value 2 укажем "Истина" (Рисунок 22)
Далее в действиях создаем "Pick Each Unit In Unit Group"(Рисунок 23)
Параметр Unit Group меняем на "Units In Unit group Matching Condition" (Рисунок 24)
Где Unit Filter открываем и двойным кликом меняем "Тип" "Воздушный" и "Неуязвимый" на "Исключено"
Так же снимаем галки "Союзник" и "Противник" (Рисунок 25)
Далее в Actions создаем проверку (If) (Рисунок 26)
Где If создадим устловие. В этом в условии:
Где Value 1 поменяем на Height At Point (Рисунок 27)
Где Unit меняем на Picked Unit (Рисунок 28)
Где Operator меняем на &lt;= (Меньше или равно)
Где Value 2 указываем значение, которое чуть меньше чем высота поднятой лавы. (Рисунок 29)
Это нужно для того, чтобы юниты получали урон зайдя в лаву, а не приблизившись к ней.
Далее в Then добавим действие Add Behavior (Player) (Рисунок 30)
Где Behavior укажем "Лава (урон)" (Рисунок 31)
Где Unit укажем Picked Unit (Рисунок 32)
Где Player укажем 15
Триггер на получение урона готов. (Рисунок 33)

Теперь нужно вернуться в триггер, который поднимает и опускает лаву.
В нем в обоих Trigger On/Off, где "Current Trigger" меняем на наш триггер получения урона.
(Рисунок 34)

Готово.</value>
            </setting>
            <setting name="Module3_Vopros2" serializeAs="String">
                <value>Как добавить на карту всех юнитов (протосов-подвиды талдаримы, неразимы и т.д и другие расы)?</value>
            </setting>
            <setting name="Module3_Otvet2" serializeAs="String">
                <value>При создании карты, указывайте карту игротеки или модификацию (Рисунок 1)
Вы можете нажать "стадрат", выбрать нужную кампанию и установить галку "данные кампании" (Рисунок 2)
Но со временем я выянил, что он не всегда включает все данные, всех трех кампаний и по этому сделаем по-другому
Нажимаем "По выбору" (Рисунок 3)
Нажимаем "Стандарт" и указываем галки всех трех кампаний + по желанию Nova (Рисунок 4)
Не указываем "Сетевой режим" вместе с ресурсами кампании, так как они будут конфликтовать
В итоге получится такой список (Рисунок 5)
Теперь нам доступны юниты из всех кампаний (Рисунок 6)</value>
            </setting>
            <setting name="Module2_Vopros3" serializeAs="String">
                <value>Как сменить освещение на карте?</value>
            </setting>
            <setting name="Module2_Otvet3" serializeAs="String">
                <value>Для начала можете открыть отдельное окно со всеми освещениями (Рисунок 1 и Рисунок 2)
Это может быть полезно для того, чтобы посмотреть как на вашей карте будет выглядеть конкретное освещение
Варианты освещения можно нажимать и смотреть (Рисунок 3 и Рисунок 4)

Чтобы применить понравившееся, нужно в модуле триггеров, создать действие "Set lighting" (Рисунок 5)
Где Light - указываете освещение (Рисунок 6)
Где Blend Time - указываете время, в течении которого применится освещение (Рисунок 7)
Если указать 0, то оно будет применено мгновенно

Освещение обратно не сменится, пока вы сами не создадите действие триггеров, на примение другого освещения карты.
Готово.</value>
            </setting>
            <setting name="Module3_Vopros3" serializeAs="String">
                <value>Как сделать так что-бы за каждый выстрел (например морпеха) тратилась 1 единица энергии?</value>
            </setting>
            <setting name="Module3_Otvet3" serializeAs="String">
                <value>В данных, во вкладке "Единицы", найдите юнита, которому вы хотите сделать атаку за энергию(Рисунок 1)
Измените ему поле "Начальный запас энергии" и "Максимальное кол-во энергии" на нужное вам заначение(например 10) (Рисунок 2 и 3)
Проверье, чтобы "Скорость восстановления энергии была равна нулю" (Рисунок 3)
Далее во вкладке "Оружие", или перейдя прямо к нему из связанных объектов с единицей, найдите оружие вашего юнита (Рисунок 4)
Найдите у него поле "Стоимость +" (Рисунок 5)
Где "Основные показатели ^", измените "Энергия" на требуемое значение для каждой атаки(например 1) (Рисунок 6)
Нажмите ОК

Все готово, теперь при атаке юнит будет расходовать собственную энергию, а когда она закончится, он не сможет атаковать.
</value>
            </setting>
            <setting name="Module3_Vopros4" serializeAs="String">
                <value>Как поменять размер юнита?</value>
            </setting>
            <setting name="Module3_Otvet4" serializeAs="String">
                <value>В данных найдите своего юнита, которому хотите изменить размер (Рисунок 1)

Способ 1:
У него найдите агент(Рисунок 2) и свойство "Шкала" (Рисунок 3)
Чтобы понять как вам указать нужный размер, нужно понять как в ск2 выглядят проценты
1 - это означает 100%
0.1 - это означает 10%
0.01 - это означает 1%
Что касается размера юнита, то по умолчанию 100%, и если вы хотите изменить размер, то нужно указывать число после единицы или вместо единицы
Например:
2 - увеличение размера на 100%
1.1 - увеличение размера на 10%
1.01 - увеличение размера на 1%

Изменим размер на 100% (Рисунок 4)
Теперь морпех увеличился в 2 раза (Рисунок 5)

Способ 2:
У вашего юнита найдите основную модель (Рисунок 6)
Там найдите и измените поле "Минимальный масштаб" и "Максимальный масштаб" (Рисунок 7 и 8)
Готово.</value>
            </setting>
            <setting name="Module3_Vopros5" serializeAs="String">
                <value>Как сменить модель юнита?</value>
            </setting>
            <setting name="Module3_Otvet5" serializeAs="String">
                <value>Разместим на карте юнита, которому хотим изменить модель (Рисунок 1)

В данных найдем этого юнита (Рисунок 2)
Вариант 1:
У него откроем агент (Рисунок 3)
Найдем поля: Модель, Модель (постройка) и Модель (размещение) (Рисунок 4)
Таким способом вы можете изменить текущую модель на другую, со всеми настройками
Но для этого нужно понимать, какую именно модель нужно выбирать
Если вам нужна модель юнита, то чаще всего они будут иметь название без лишних частей
Например: Marine, Medivac, Mothership и тд.
Так же, в списке сортировки, вы можете указать тип "Unit" (Рисунок 5)
Но минус такого способа в том, что близзард наделали кучу типов, с конкетным названием юнита и вы можете не найти основную модель нужного юнита
Пример можно увидеть на Рисунке 6 и Рисунке 7

Укажем модель пилона(Рисунок 8) и укажем их в оставшиеся 2 поля(Рисунок 9)
Вы можете нажать Ctrl + C на первое поле и Ctrl + V на оставшиеся 2 поля
Теперь морпех у нас выглядит как пилон(Рисунок 10 и Рисунок 11)

Вариант 2:
Найдите у вашего юнита основную модель (Рисунок 12)
Найдите у нее поле "Модель" (Рисунок 13)
Открыв его, нажмите "Обзор" (Рисунок 14)
В списке найдите нужную модель (Рисунок 15)
Я указал в качестве примера модель крейсера (Рисунок 16)
Теперь морпех выглядит как крейсер (Рисунок 17 и Рисунок 18)</value>
            </setting>
            <setting name="Module1_Vopros0" serializeAs="String">
                <value>Все юниты вдруг начали летать, как это изменить?</value>
            </setting>
            <setting name="Module1_Otvet0" serializeAs="String">
                <value>Все юниты вдруг начали летать, как это изменить?

За это отвечает поле высот. Если оно настроенно не правильно, юниты будут "летать"
Я создал простую поверхность, чтобы показать как это работает (Рисунок 1-3)
Как видим, все нормально, юниты не "летают", а стоят на земле
Но если мы подведем морпеха в яму, то увидим что он стоит "на воздухе" (Рисунок 4)
По умолчанию базовая высота равна 8 единицам (Рисунок 5)
Посмотреть и изменить это значение можно в настройках карты (Рисунок 6)
Так же, чтобы понять какая именно высота вам нужна, нужно включить ее отображение на поверхности (Рисунок 7)
Теперь на повехности видим оранжевые полости, показывающие нам ниже какой высоты не может опуститься юнит (Рисунок 8)
Это можно изменить, просто убрав галку "Базовая высота для всех боевых единиц" (Рисунок 9)
Теперь юниты смогут спускаться в ямы, а не ходить "по воздуху"

Но это не решает проблему того, что юниты вдруг начали "летать"
Чтобы это исправить, нужно проверить чтобы базовая высота была равна 8 единицам, как это должно быть по умолчанию
Возможно, конкретно для вашей карты нужно будет другое значение и тут только эксперементировать
Перед тем, как изменять высоту, сохраните копию карты, так как измение высоты может привести к необратимому выравниванию поверхности

Теперь рассмотрим вариант по теме вопроса:
Изменим высоту например на 10 единиц и видим, что над поверхностью имеется оранжевый квадрат по всей карте
Теперь это минимальная высота для юнитов и это приводит к тому, что они летают (Рисунок 10)
Запустив игру, мы можем наблюдать следующую картину (Рисунок 11)
Все юниты, включая даже минералы, находятся "в воздухе"
Исправляем это изменением высоты до значения по умолчанию(то есть 8 единиц)

Готово.
Теперь вы знаете как работает поле высот и возможно решили свою проблему с "летающими" юнитами.</value>
            </setting>
            <setting name="Module2_Vopros4" serializeAs="String">
                <value>Как сменить скины юнитов?</value>
            </setting>
            <setting name="Module2_Otvet4" serializeAs="String">
                <value>Смена скинов происходит через действия триггеров

Для начала разместим несколько юнитов, для того, чтобы посмотреть что это работает (Рисунок 1)
Далее заходим в модуль Триггеров и выбираем созданный по умолчанию триггер "Инициализация схватки"
У него в действиях нужно создать "Apply Player Skin" (Рисунок 2)
Там есть просто "Apply Player Skin" и "Apply Player Skin (Peplacing Existing Unit)"
Apply Player Skin - применяет скин, но не заменяет модели у уже созданных на карте юнитов
Apply Player Skin (Peplacing Existing Unit) - делает тоже самое, только заменяет модели у уже созданных на карте юнитов

Создадим оба этих действия для наглядности (Рисунок 3)
Теперь выбираем любое из этих действий и где "No Game Link", мы можем указать конкетный скин 
(Рисунок 4)
Но проблема в том, что они все называются одинаково и если вам нужен один конкетный скин, его будет найти очень сложно
Например, на этой тестовой карте, я хочу использовать только гидралисков и гиблингов 
Чтобы их найти, придется буквально все скины перебирать по одному, чтобы найти нужный

Чтобы этого не делать, мы зайдем в модуль Данных и откроем там вкладку "Облики" из раздела "Герой" (Рисунок 5)
Теперь мы видим все доступные скины (Рисунок 6)
Далее мы просто нажимаем на любой из них и в свойтсвах ищем поле "Отобразить модель+"
В этом после написано имя юнита, которому будет заменена модель
Если вы все еще не можете понять что это за юнит, вы можете открыть поле "Значок вариаций" 
(Рисунок 8 и 9)

Теперь, чтобы нам упростить себе жизнь, мы можем добавать "Префикс редактора" или "Суффикс редактора"
Это нужно для того, чтобы в триггерах проще было найти нужный скин
Например, я добавлю "Префикс" на скин для гиблингов и гидралисков
(Префикс и Суффикс - это тоже свойсва, как и "Отобразить модель+")

Далее вернувшись в триггеры, я могу при помощи поиска легко найти нужные мне скины (Рисунок 10)
Установлю скины таким образом:
Apply Player Skin - Выберу там гиблингов
Apply Player Skin (Peplacing Existing Unit) - Выберу там гидралисков (Рисунок 11)

Запустив игру, мы можем видеть что у гиблингов скин не поменялся, а у гидралисков поменялся (Рисунок 12)
Это связно с тем, что гиблинги сразу есть на карте и скины будут применены только к новым, созданным юнитам (Рисунок 13)

Таким образом, мы выяснили что нужно использовать "Apply Player Skin (Peplacing Existing Unit)"
Так же, при смене скинов, нунжо указывать игрока(по умолчанию 1)
Если у вас на карте 10 игроков, то скины нужно применять для всех
Еще если вы хотите все скины, то их так же, все нужно указывать при помощи действий триггеров (Рисунок 14)
На скриншоте я указал не все, так как это просто пример

Теперь вариант, как можно все эти скины, применить ко всем 10-ти игрокам
Вы можете создать цикл, который сделает все за вас
Создадим "Pick Each Integer"(Рисунок 15) и поместим наши действия на смену скинов, в этот цикл (Рисунок 16)
Начало и конец цикла можно менять (Рисунок 17)
Теперь в наших действиях по смене скинов, где "Player 1", открываем, меняем на "Фукнкция" и указываем "Picked Integer" (Рисунок 18)
Теперь вы можете просто скопировать этот параметр для остальных действий (Рисунок 19 и 20)

Все готово.
Теперь вы знаете как менять скины и где их найти.</value>
            </setting>
            <setting name="Module11_Vopros0" serializeAs="String">
                <value>Как скачать и редактировать карту из игротеки?</value>
            </setting>
            <setting name="Module11_Otvet0" serializeAs="String">
                <value>Чтобы открыть карту опубликованные карты, нужно для начала нажать кнопку открытия карты (Рисунок 1)
Потом нужно переключиться на вкладку "Blizzard" и авторизоваться (Рисунок 2)
Там можно еще выбрать регион, но в теории, он сам его определит при авторизации
Если этого не произошло, попробуйте указать его вручную

Теперь вы можете указать "Источник" (Рисунок 3)
Выбрав один из источников, найдите в списке нужную карту, нажмите "Загрузить" и нажмите "ОК" (Рисунок 4)

Все готово, вы открыли опубликованную карту и можете ее редактировать.
При открытии опубликованных карт, есть нюанс, а именно: вы не можете открыть и редактировать "Закрытые карты"
Если нужная вам карта не находится по названию и последним сыгранным играм, возможно она закрыта для редактирования.
При публикации карты, каждый автор указывает, можно или нельзя ли будет редактировать его карту.
Так же, если вы являетесь автором этой карты и утратили исходники, то скорее всего тут ничего не поделать, так как даже собственные карты нельзя открывать таким способом.

Если вы хотите скачать какую-то свою карту, то можете использовать "Управление опубликованными материалами" (Рисунок 5)
Что представляет из себя почти тоже самое, только отображает карты, опубликованные вами.</value>
            </setting>
            <setting name="Module2_Vopros5" serializeAs="String">
                <value>Как сделать другого игрока союзником?</value>
            </setting>
            <setting name="Module2_Otvet5" serializeAs="String">
                <value>Зайдем в модуль Триггеров и откроем созданный по умолчанию триггер "Инициализация схватки"

Вариант 1: Самый простой
В действиях этого триггера, создадим "Set Allliance" (Рисунок 1)
Это действие позволяет задать союз между двумя игроками (Рисунок 2)
Где Source Player и Target Player можете указывать двух игроков, которые должны быть в союзе
Так же вы можете выбрать варианты союзов:
1) Просто союзники (без общего обзора)
2) Союзники с общим обзором
3) Союзники с общим обзором и контролем
4) Союзники с общим обзором и чем-то еще (не проверял)
5) Союзники с общим обзором, контролем и припасами/ресурсами(не точно)
6) Враги
7) Враги с общим обзором
8) Нейтралы
9) Нейтралы с общим обзором
10) Нейтралы с общим обзором и чем-то еще (не проверял)
(Рисунок 3)

Если на карте много игроков, такой способ будет не очень удобен, так как каждый игрок должен быть в союзе со всеми остальными игроками
Вам придется много раз копировать это действие и вручную указывать союзы для каждого игрока

Вариант 2: Сложнее, но удобнее
Будем использовать переменную для удобства добавления игроков
Так как союзы задаются в основном при старте карты, то использовать эту переменную как глобальную, нет смысла и по этому создадим ее как локальную
Нажимаем на "Local Variables" и нажимаем Ctrl + W (это создать новый элемент)
Созданную переменную назовем "Player Group" и укажем ей тип "Группа игрока" (Рисунок 4)
Далее создадим действие "Add Player To Player Group" (Рисунок 5 и 6)
Где Player Group нажимаем и выбираем нашу переменную "Player Group" (Рисунок 7)
Таким образом, копируем наше получившееся действие сколько нам нужно(например 4 раза) и меняем игроков (Рисунок 8)
Создадим действие "Set alliance For Player Group" (Рисунок 9)
Где Player Group нажимаем и выбираем нашу переменную

Все готово.
Теперь игроки будут союзниками.

Естественно, если у вас 15 игроков и вам нужно чтобы они были союзниками, то вы можете использовать цикл, для добавления всех игроков в группу.</value>
            </setting>
            <setting name="Module1_Vopros1" serializeAs="String">
                <value>Пропала/не отображается панель редактирования поверхности, как исправить?</value>
            </setting>
            <setting name="Module1_Otvet1" serializeAs="String">
                <value>Представим такую картину, что вы впервые открылили редактор или случайно что-то нажали и у вас не отображается панель редактирования поверхности (Рисунок 1)
Все, что вам нужно сделать, так это нажать кнопку "Вид" на верхней панели и снова включить "Показать панель интерфейса" (Рисунок 2)

Готово.
Теперь вы снова можете редактировать поверхность. (Рисунок 3)</value>
            </setting>
            <setting name="Module1_Vopros2" serializeAs="String">
                <value>Не отоборажаются кноки редактирования поверхности, как исправить?</value>
            </setting>
            <setting name="Module1_Otvet2" serializeAs="String">
                <value>Представим такую картину, что вы впервые открылили редактор или случайно что-то сделали и у вас не отображаются кнопки редактирования поверхности (Рисунок 1)
Все, что вам нужно сделать, так это либо нажать на стрелки, либо навестись мышкой на одну из видимых кнопок и прокрутить колесико мыши вверх (Рисунок 2)

Готово.
Теперь вы снова можете редактировать поверхность. (Рисунок 3)</value>
            </setting>
            <setting name="Module3_Vopros6" serializeAs="String">
                <value>Как изменить цвет юнита?</value>
            </setting>
            <setting name="Module3_Vopros7" serializeAs="String">
                <value>Как изменить дальность оружия?</value>
            </setting>
            <setting name="Module3_Vopros8" serializeAs="String">
                <value>Как изменить скорость атаки оружия?</value>
            </setting>
            <setting name="Module3_Vopros9" serializeAs="String">
                <value>Как изменить урон оружия юнита?</value>
            </setting>
            <setting name="Module3_Otvet6" serializeAs="String">
                <value>Найдите юнита, которому вы хотите изменить цвет.
Откройте его Агент (Рисунок 1) и найдите поле "События+". (Рисунок 2)
Открыв события, нажмите ПКМ в любом свободном месте.
Из появившегося списка выберите "Добавить событие". (Рисунок 3)
Будет создано событие с прикрепленным к нему действием. (Рисунок 4)
Тип сообщения меняете на "Создание агента".
Далее выбираем действие и меняем его на "Задать оттенок".
В конце можно будет наглядно увидеть разницу между двумя юнитами.
Все параметры оставляете без изменений и указываете только нужный цвет и жмете ок.
После снова нажимаете ок и все готово. (Рисунок 8)
Рисунок 9 - Вид из редактора.
Рисунок 10 - Вид из игры.</value>
            </setting>
            <setting name="Module3_Otvet9" serializeAs="String">
                <value>Для того, что изменить урон оружия юнита, нужно для начала найти эффект урона, который наносит это оружие
Нажмите на оружие юнита и посмотрите, какой эффект указан в поле "Эффект" (Рисунок 1)
Так как у морпеха оружие не имеет снаряда, то у него в оружии сразу указан эффект урона (Рисунок 2)
Перейдя в этот эффект, найдите поле "Количество+"
У морпеха по умолчанию указано значение "6", это и есть урон его оружия
Вы можете менять это значение на любое другое

Вариант 2: Оружие со снарядом
Взяв в пример оружие мародера, видим что у него больше эффектов, связанных с его оружием (Рисунок 3)
Перейдя в его оружие, в поле эффекта, видим эффект запуска снаряда (Рисунок 5)
Теперь прейдем в эффект запуска снаряда, чтобы посмотреть с чем он еще связан (Рисунок 6)
Перейдем и в этот эффект и видим там эффект замедления и эффект насения урона (Рисунок 7)
Так мы последовательно выяснили какой именно эффект урона отвечает за его оружие
Это может быть полезно для юнитов, у которых несколько оружий или юнитов, которые используют оружие с несколькими уронами (Например, излучатель пустоты)</value>
            </setting>
            <setting name="Module3_Otvet8" serializeAs="String">
                <value>Для того, что изменить скорость атаки оружия юнита, нужно для начала перейти в его оружие
Нажмите на оружие юнита и найдите после "Интервал" (Рисунок 1)

У мародера по умолчанию 1.5 время между атаками
Вы можете менять это значение на любое другое

Готово.</value>
            </setting>
            <setting name="Module3_Otvet7" serializeAs="String">
                <value>Для того, что изменить дальность атаки оружия юнита, нужно для начала перейти в его оружие
Нажмите на оружие юнита и найдите после "Дальность" (Рисунок 1)

У мародера по умолчанию дальность 6
Вы можете менять это значение на любое другое

Готово.</value>
            </setting>
            <setting name="Module10_Vopros0" serializeAs="String">
                <value>Как сделать ботов по сложнее?</value>
            </setting>
            <setting name="Module10_Otvet0" serializeAs="String">
                <value>Чтобы изменить сложность ботов, зайдите для начала в настройки (Рисунок 1)
Перейдите во вкладку "Пробный запуск" и найдите "Сложность игры" (Рисунок 2)
Теперь вы можете изменить сложность ботов по умолчанию

Готово.</value>
            </setting>
            <setting name="Module2_Vopros6" serializeAs="String">
                <value>Как сделать смену дня и ночи?</value>
            </setting>
            <setting name="Module2_Otvet6" serializeAs="String">
                <value>Зайдите в Модуль триггеров и создайте новый триггер (Рисунок 1)
Создадим глобальную переменную, которая будет отвечать за День и Ночь 
Назовем ее "Day/Night", укажем тип "Булево" и начальное значение поменяем на "Истина"(Рисунок 2)
Определять будем так:
Истина - это день
Ложь - это ночь

Вернемя в триггер и создадим событие "Map initialization", которое будет выбрано по умолчанию сразу и сработает, как только карта загрузится (Рисунок 3)
Переходим сразу к действиям и создадим бесконечный цикл, который и будет запускать смену дня и ночи
Сделаем каркас для смены для и ночи, а потом сделаем отображения таймера

Создаем действие "Repeat Forever" (Рисунок 4)
В действиях этого цикла создадим "Wait" и укажем в него время, сколько будет идти день
В качестве примера укажу 30 секунд (Рисунок 5)
Так как у нас по умолчанию День и этот триггер сработает при старте карты, то ему нужно только ждать наступление ночи

После Wait создадим действие "Set Lighting" (Рисунок 6)
Где Light - укажем какое-нибудь освещение карты для ночи
Где Blend Time - время, в течении которого применится это освещение (Рисунок 7) (Со временем эксперементируйте)
Чтобы понять, какое освещение вам больше подходит, вы можете посмотреть их в отдельном окне "Освещение" (Рисунок 8, 9 и 10)
Так же можете посмотреть вопрос "Как сменить освещение карты?", чтобы более подробно об этом узнать

Теперь после "Set Lighting" создадим действие "Set Variable" (Рисунок 11)
Где Variable - Укажем нашу переменную (Рисунок 12)
Где Value - Откроем и просто нажмем "Ок", без установки галки на "Истина" (Рисунок 13)
Это мы сделали смену на ночь

Теперь сделаем смену на день
Скоприуем "Wait" и вставим его после "Set Value" (Рисунок 14)
Значение в этом ожидании, будет означать сколько длится ночь
Скоприуем так же "Set Light" и вставим его после "Wait" 
Как и в прошлый раз, изменим освещение на дневное (в моем случае это Argia) (Рисунок 15)
Скоприуем "Set Variable" и изменим заначение "Flalse" на "Истина" (Рисунок 16)

Каркас для смены дня и ночи готов.
Теперь можно прикрутить сюда таймер, для отображения длительности дня и ночи.

Создадим одну локальную переменную, назовем ее "Time of Day" и укажем тип "Таймер" (Рисунок 17)
Тут же, сразу создадим переменную, для отображения нашего таймера
Создаем еще одну локальную переменную, назовем ее "Timer Window" и укажем тип "Timer Window" (Рисунок 18)

Теперь в цикле, перед ожиданием для ночи, создадим действие "Start Timer" (Рисунок 19)
Где Timer - Открываем и указываем нашу переменную "Time of Day"
Где One Shot - Оставляем без изменений
Где Duration - Укажем сколько времени осталось до наступления ночи
В моем случае это 30 секунд

После создаем "Set Variable"
Где Variable - Укажем нашу переменную таймера "Time of Day" (Рисунок 20)
Где Value - Откроем, переключим на "функция" и укажем "Last Started Timer" (Рисунок 21)

Создадим следующее действие "Create Timer Window" (Рисунок 22)
Где Last Started Timer - Откроем, переключим на "Переменная" и укажем нашу переменную "Time of Day"
Где Title - Можете написать что-то вроде "День" (Рисунок 23)

Так же, после этого создадим действие "Set Variable"
Где Variable - Укажем нашу переменную "Timer Window"
Где Value - Откроем, переключим на "функция" и укажем "Last Created Timer Window" (Рисунок 24)

Теперь 4 действия, связанные с таймером скопируйте и вставьте после наступления ночи
То есть после "Set Variable" со значением "False" (Рисунок 25)
В "Create Timer Window" измените текст "День", на "Ночь"
В "Start Timer" измените время на то, сколько у вас длится ночь (Рисунок 26)

Уже в процессе добавления вопроса, заметил что забыл дописать одну строку, из-за которой у вас с каждым новым днем или ночью, будет создаваться новое окно с таймером
Это не правильно, он должен удалять старый и создавать новый
Вам нужно только добавить 2 действия "Destroy Timer Window" и указать туда переменную "Timer Window"
Разместить их перед действием "Create Timer Window"
Рисунок я добавил в самый конец (Рисунок 33)

Все готово.
Теперь у вас будет смена дня и ночи.

Такой способ очень простой и без лишних заморочек.
Если вы хотите привязать какие-то события на срабатывание таймера дня и ночи, то переменную "Time of Day" вам нужно будет просто перенести из локальных, в глобальные.
Потому что если переменная локальная, то вы не сможете получить к ней доступ из других триггеров.

Вот как перенести ее:
Скоруйте ее, нажмите на любой триггер или глобальную переменную и вставьте (Рисунок 27 и 28)
Вернитесь в триггер, нажмите на локальную версию этой переменной и нажмите "Delete" (Рисунок 29)
Он вам покажет что она задействована N кол-во раз
Нажимаем "Ок" и видим что везде, где она использовалась, подсвечивает красным (Рисунок 30)
Теперь просто вручную указываем нашу глобальную переменную (Рисунок 31 и 32)

Но с точки зрения удобства, это не очень правильно.
Вы можете использовать нажать на локальную переменную и нажать Ctrl + F10, чтобы посмотерть где она используется.
Так же, вы можете нажимать двойным кликом и переходить в конктреное место, к конкретному действию или функции, где используется переменная.
Это будет более правильно и более удобно.
На скришотах я показал вариант, когда триггер не большой и переменная почти нигде не используется.

Готово.
Теперь вы перенесли локальную переменная в глобальные и подставили ее везде, где она использовалась.
Так вы сможете использовать ее в других триггерах.</value>
            </setting>
        </SC2MapEdtiorXeX.Properties.Settings>
    </applicationSettings>
    <userSettings>
        <SC2MapEdtiorXeXxD.Properties.Settings>
            <setting name="Module2_Otvet10" serializeAs="String">
                <value>Заходим в Модуль Триггеров

Для затемнения и осветления экрана, вам нужно создать всего 2 действия
Затемнение:
Создаем действие Cinematic Mode (Рисунок 0 и 1)
Оно потребуется для того, чтобы игрок не смог ничего нажать во время затемнения экрана
Вы можете указать конкретного игрока, но в следующем действии, которое будет отвечать конкретно за затемнение, нельзя указать игрока и поэтому оно делается для всех игроков сразу (Рисунок 2)

Создаем действие Fade In/Out (Рисунок 3 и 4)
Где Fade In - Меняем на Fade Out (Рисунок 5)
Где Duration - Указывайте время, в течении которого будет затемняться/осветляться экран

Это мы сделали затемнение экрана и теперь нужно сделать только осветление экрана
Действия для осветления экрана можно размещать даже в других триггерах

Скопируйте предыдущие 2 действия и разместите их там, где должно происходить осветление экрана
Например, можете сделать в этом же триггере ожидание 10 секунд, разместить их после ожидания и изменить:
В действии Cinematic Mode, значение On измените на Off (Рисунок 6)
В действии Fade In/Out, значение Fade Out измените на Fade In(Рисунок 7)

В последнее время заметил, что бывают случаи, когда по такой настройке затемнение не работает и решить это обычно можно так:
В действиях Fade In/Out поменяйте Fade In и Fade Out местами так, чтобы на затемнение было Fade In, а за осветление Fade Out.

Все готово.
Теперь вы можете запустить карту и посмотреть, как это работает.
Так же, как я и писал выше, действие на осветление экрана, можно размещать в других триггерах.
Например, чтобы затемнить экран и скрыть мгновенное перемещение юнитов из одной точки, в другую.</value>
            </setting>
            <setting name="Module2_Vopros11" serializeAs="String">
                <value>Измение лимита на юнитов на карте</value>
            </setting>
            <setting name="Module2_Otvet11" serializeAs="String">
                <value>Заходим в модуль триггеров

Возьмем, к примеру, триггер инициализации карты и у него в действиях создадим:
Modify Player Property(Рисунок 0)
Игрока оставим пока без изменений
Где Minerals - открываем и меняем на "Supplies Limit" (Рисунок 1)
Где Set To - означает установить, Add - добавить, Subtract - отнять (Рисунок 2)
Оставим по умолчанию и идем дальше
Где 1000 - указывайте значение, которое будет равно лимиту припасов
Если оставить по умолчанию, то лимит будет 1000 припасов

Скопируем это действие и "Supplies Limit" изменим на "Supplies Made"
Теперь у игрока 1 будет 1000 лимита припасов

Теперь нужно их увеличить для нескольких игроков, если у вас более одного игрока на карте
Это можно так же сделать двумя способами:
Способ 1: Если вы новичок и вам не хочется лишний раз заморачиваться, то можете скопировать вот эти два действия на припасы, и менять игроков, как это показано на (Рисунок 3)
Способ 2: При помощи цикла
Создайте действие "pick each integer" (Рисунок 4) и укажите в нем:
Где Start - игрока, c которого начинается отсчет игроков, которыми управляют люди (по умолчанию с первого до N)
Где End - игрока, на котором заканчивается отсчет игроков, которыми управляют люди (например, 4)

Поместим в него 2 действия, которые дают "Supplies Limit" и "Supplies Made", а лишние удалим (Рисунок 5)
Где Player 1 переключаем на "функция" и указываем "picked Integer" (Рисунок 6)
Сделаем тоже самое для второго действия (Рисунок 7)

Все готово.
Теперь припасы изменены.</value>
            </setting>
            <setting name="Module2_Vopros14" serializeAs="String">
                <value>Спавн юнитов в определенной точке при входе игрока в область</value>
            </setting>
            <setting name="Module2_Otvet19" serializeAs="String">
                <value>Это делается через триггеры и для примера, я создам простую карту (Рисунок 0)
На скриншоте я создал область, но вы можете этого и не делать
Тут все зависит от того, что именно вы хотите сделать

Отдать приказ на добычу можно указав определенную область или всю карту
В случае всей карты, область будет вам не нужна

Заходим в Модуль Триггеров
Выбираем созданный по умолчанию триггер "Инициализация схватки"
Так как для меня это тестовая карта, то я удалю из него не нужные действия (Рисунок 1)

Создадим действие "Order Workers to Gather Nearby Resources" (Рисунок 2)

Вариант 1: Вся карта
Если вам нужно чтобы все рабочие определенного игрока, на всей карте начали добывать ближайшие минералы, то оставляете область без изменений
Изменить нужно только игрока (если нужным вам игрок не первый)

Выглядеть это будет вот так (Рисунок 3)
Как видим все рабочие, самостоятельно добывают ресурсы

Вариант 2: Указание определенной области
Если вам нужно чтобы добыча началась в определенной области, то нужно изменить:
Где Region - Указываете "Значение - Ваша область" (Рисунок 4)

Это будет работать точно так же, только добывать они начнут в этой области, а не по всей карте</value>
            </setting>
            <setting name="AppSizeX" serializeAs="String">
                <value>0</value>
            </setting>
            <setting name="AppSizeY" serializeAs="String">
                <value>0</value>
            </setting>
            <setting name="Module2_Otvet24" serializeAs="String">
                <value>Чтобы создать таймер, нужно создать переменную с этим типом (Рисунок 0)

После этого нужно запустить таймер, используя действие "Start Timer"(Рисунок 1)
В параметры этого действия нужно указать нашу переменную таймера (Рисунок 2)
One Shot - Означает, что таймер сработает только один раз
Repeating - Означает, что таймер будет перезапускаться по окончанию времени (Рисунок 3)
Duration - Означает, сколько времени потребуется для срабатывания таймера

После запуска таймера, нужно записать его в переменную, чтобы можно было отследить его окончание (Рисунок 4)
Где Variable - Указываем нашу переменную (Рисунок 5)
Где Value - Указываем "Last Started Timer" (Рисунок 6)

Теперь, используя эту переменную, мы можем отследить окончание этого таймера в другом триггере
Создадим новый триггер и укажем событие "Timer Expires" (Рисунок 7)
Где Timer - Указываем нашу переменную (Рисунок 8)

В итоге, наш новый триггер будет срабатывать, когда таймер закончится
Создадим тестовое сообщение для проверки (Рисунок 9 и 10)</value>
            </setting>
        </SC2MapEdtiorXeXxD.Properties.Settings>
    </userSettings>
</configuration>
