<?xml version="1.0" encoding="utf-8" ?>
<configuration>
    <configSections>
        <sectionGroup name="applicationSettings" type="System.Configuration.ApplicationSettingsGroup, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" >
            <section name="SC2MapEdtiorXeXxD.Properties.Settings" type="System.Configuration.ClientSettingsSection, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" requirePermission="false" />
            <section name="SC2MapEdtiorXeX.Properties.Settings" type="System.Configuration.ClientSettingsSection, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" requirePermission="false" />
        </sectionGroup>
    </configSections>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.6.1" />
    </startup>
    <applicationSettings>
        <SC2MapEdtiorXeXxD.Properties.Settings>
            <setting name="Module2_Otvet0" serializeAs="String">
                <value>Создаем новый триггер (Рисунок 1)
В нем создаем событие Chat Message (Рисунок 2)
Создав его, мы видим параметры, которое может принимать это событие (Рисунок 3)
Далее где Text: вписываете команду, на которую будет срабатывать триггер

Теперь создаем локальную переменную, называем ее Units (название может быть любым) и указываем ей тип "группа единиц" (Рисунок 4)
Создаем действие Set Varialbe (Рисунок 5)
Где Varible, указываем свою переменную Units (Рисунок 6)
Где Value, указываем: функция - Selected Units (Рисунок 7)
Где Player, указываем Triggering Player (Рисунок 8)

Далее создаем действие Pick Each Unit In Unit Group (Рисунок 9)
Где Unit Group, указываем нашу переменную Units (Рисунок 10)

Теперь тут же создаем действие If Then Else (Рисунок 11)
Где if создаем новый элемент(по умолчанию сравнение)(Ctrl + W) (Рисунок 12)
Где Value 1: Owner of Unit есть параметр Unit
В него указываем Picked Unit (Рисунок 13)
Где Value 2: Меняем на Triggering Player (Рисунок 14)
Далее в Then создаем действие Kill Unit (Рисунок 15)
Triggering Unit меняем на Picked Unit (Рисунок 16)

Готово.
Триггер на убийство юнитов при вводе команды чат готов.</value>
            </setting>
            <setting name="Module3_Vopros0" serializeAs="String">
                <value>Начало работы с модуем данных</value>
            </setting>
            <setting name="Module3_Vopros1" serializeAs="String">
                <value>Как сделать чтобы за убийство давались ресурсы?</value>
            </setting>
            <setting name="Module3_Otvet1" serializeAs="String">
                <value>Открыв вкладку "Единицы" найдите там юнита, за убийство которого будут даваться ресурсы.
Найдите поле "Уничтожить ресурс+" и открыв его, вы можете указать до 4х разных ресурсов.
Указывайте нужно количество и жмите ок.
Готово.</value>
            </setting>
            <setting name="Module3_Otvet0" serializeAs="String">
                <value>Для начала работы с модулем даныых, выставьте настройки таким образом (Рисунок 1)
Чтобы находить любые нужные данные, вы можете открывать и добавлять себе любые доступные вкладки (Рисунок 2)

Это нужно для того, чтобы при просмотре ответов на вопросы по модулю данных, у вас не возникали вопросы, с непониманием того, почему у меня что-то отображается, а у вас нет

Например, чтобы вы так же легко могли открыть агент любого юнита или любой другой объект, связанный с юнитом

Готово.</value>
            </setting>
            <setting name="Module2_Vopros0" serializeAs="String">
                <value>Как сделать убийство выбранного юнита при вводе команды в чат?</value>
            </setting>
            <setting name="Module2_Vopros1" serializeAs="String">
                <value>Какой ивент в триггерах делает что-бы после наступления определенного времени, происходило какое-нибудь действие?</value>
            </setting>
            <setting name="Module2_Otvet1" serializeAs="String">
                <value>За это отвечает событие "Time Elapsed" и "Periodic Event"
Находятся они по метке "Time" (Рисунок 1)

Вариант 1: Time Elapsed
Это событие отвечает за "Время прошло" и запускается один раз
Можно указывать время в секундах и тип времени (Рисунок 2)

Добавив вывод сообщения со временем миссии в чат, увидим такую картину (Рисунок 3)

Вариант 2: Periodic Event
Это событие отвечает за периодические события и запускается бесконечное кол-во раз
Так же можно указывать время в секундах и тип времени (Рисунок 4)

Добавив вывод сообщения со временем миссии в чат, увидим такую картину (Рисунок 5)

Готово.
Теперь вы знаете как это работает.</value>
            </setting>
            <setting name="Module2_Vopros2" serializeAs="String">
                <value>Как сделать подъем и спад лавы? + урон от лавы</value>
            </setting>
            <setting name="Module2_Otvet2" serializeAs="String">
                <value>Создадим простой рельеф для поднятия лавы (Рисунок 1)
Добавим лаву (Рисунок 2)
Откроем настройки воды (Рисунок 3)
Добавим новое состояние воды и сделаем цвет такой же как в "По умолчанию" 
Так же укажем нужну нам высоту для поднятой лавы. (Рисунок 4)
Зайдем в триггеры и создадим триггер, отвечающий за подъем и спад лавы. (Рисунок 5)
Создадим событие Pereodic Event и укажем время, через которое будет подниматься лава. (Рисунок 6)
Создадим устловие (If) (Рисунок 7)
Создадим глобальную переменную Lava Up/Down с типом "Булево" (Рисунок 8)
В условии будем проверять эту переменную со значением False (Рисунок 9)
В then создадим действие Play Sound и укажем туда звук TUIlavaRising (Рисунок 10)
Создадим действие Set Water State (Рисунок 11)
Где state укажем созданное ранее состояние воды (Рисунок 12)
Где over 1.0 secodns укажем 4 сек.
Далее создадим действие Wait для того, чтобы лава чисто визуально поднялась до нужного уровня,
ниже которого юниты будут получать урон. (Рисунок 13)
Далее создадим действие Turn Trigger On/Off
Где Off меняем на On
Current Trigger пока оставляем как есть (Рисунок 14)
После создадим действие Set Variable 
Где Variable укажем нашу переменную "Lava"
Где Value укажем "Истина" (Рисунок 15)

Теперь в Else скопируем действия:
Play Sound + Set Water State + Wait + Trigger On/Off + Set Variable (Рисунок 16)
Двух секундную задержку в действии Wait меняем на 1.5 сек.
В Set Variable "Истина" меняем на "Ложь", просто убрав галку(Рисунок 17)
В Set Water State меняем состояние на "По умолчанию" (Рисунок 18)
В Trigger On/Off параметр "On" меняем на "Off" (Рисунок 19)

Дальше нужно создать триггер, который будет наносить урон юнитам в лаве
Создадим триггер Lava Damage
Нажимаем на него ПКМ и убираем галку "Изначально включен" (Рисунок 20)
Добавим в него событие "Periodic Event" и установим параметр "Duration" на значение "0.5" (Рисунок 21)
Далее в условии триггера добавим условие(просто crtl + w + enter)
Где Value 1 укажем "Trigger Is On"
Где Value 2 укажем "Истина" (Рисунок 22)
Далее в действиях создаем "Pick Each Unit In Unit Group"(Рисунок 23)
Параметр Unit Group меняем на "Units In Unit group Matching Condition" (Рисунок 24)
Где Unit Filter открываем и двойным кликом меняем "Тип" "Воздушный" и "Неуязвимый" на "Исключено"
Так же снимаем галки "Союзник" и "Противник" (Рисунок 25)
Далее в Actions создаем проверку (If) (Рисунок 26)
Где If создадим устловие. В этом в условии:
Где Value 1 поменяем на Height At Point (Рисунок 27)
Где Unit меняем на Picked Unit (Рисунок 28)
Где Operator меняем на &lt;= (Меньше или равно)
Где Value 2 указываем значение, которое чуть меньше чем высота поднятой лавы. (Рисунок 29)
Это нужно для того, чтобы юниты получали урон зайдя в лаву, а не приблизившись к ней.
Далее в Then добавим действие Add Behavior (Player) (Рисунок 30)
Где Behavior укажем "Лава (урон)" (Рисунок 31)
Где Unit укажем Picked Unit (Рисунок 32)
Где Player укажем 15
Триггер на получение урона готов. (Рисунок 33)

Теперь нужно вернуться в триггер, который поднимает и опускает лаву.
В нем в обоих Trigger On/Off, где "Current Trigger" меняем на наш триггер получения урона.
(Рисунок 34)

Готово.</value>
            </setting>
            <setting name="Module3_Vopros2" serializeAs="String">
                <value>Как добавить на карту всех юнитов (протосов-подвиды талдаримы, неразимы и т.д и другие расы)?</value>
            </setting>
            <setting name="Module3_Otvet2" serializeAs="String">
                <value>При создании карты, указывайте карту игротеки или модификацию (Рисунок 1)
Вы можете нажать "стандарт", выбрать нужную кампанию и установить галку "данные кампании" (Рисунок 2)
Но со временем я выянил, что он не всегда включает все данные, всех трех кампаний и по этому сделаем по-другому
Нажимаем "По выбору" (Рисунок 3)
Нажимаем "Стандарт" и указываем галки всех трех кампаний + по желанию Nova (Рисунок 4)
Не указываем "Сетевой режим" вместе с ресурсами кампании, так как они будут конфликтовать
В итоге получится такой список (Рисунок 5)
Теперь нам доступны юниты из всех кампаний (Рисунок 6)</value>
            </setting>
            <setting name="Module2_Vopros3" serializeAs="String">
                <value>Как сменить освещение на карте?</value>
            </setting>
            <setting name="Module2_Otvet3" serializeAs="String">
                <value>Для начала можете открыть отдельное окно со всеми освещениями (Рисунок 1 и Рисунок 2)
Это может быть полезно для того, чтобы посмотреть как на вашей карте будет выглядеть конкретное освещение
Варианты освещения можно нажимать и смотреть (Рисунок 3 и Рисунок 4)

Чтобы применить понравившееся, нужно в модуле триггеров, создать действие "Set lighting" (Рисунок 5)
Где Light - указываете освещение (Рисунок 6)
Где Blend Time - указываете время, в течении которого применится освещение (Рисунок 7)
Если указать 0, то оно будет применено мгновенно

Освещение обратно не сменится, пока вы сами не создадите действие триггеров, на примение другого освещения карты.
Готово.</value>
            </setting>
            <setting name="Module3_Vopros3" serializeAs="String">
                <value>Как сделать так что-бы за каждый выстрел (например морпеха) тратилась 1 единица энергии?</value>
            </setting>
            <setting name="Module3_Otvet3" serializeAs="String">
                <value>В данных, во вкладке "Единицы", найдите юнита, которому вы хотите сделать атаку за энергию(Рисунок 1)
Измените ему поле "Начальный запас энергии" и "Максимальное кол-во энергии" на нужное вам заначение(например 10) (Рисунок 2 и 3)
Проверье, чтобы "Скорость восстановления энергии была равна нулю" (Рисунок 3)
Далее во вкладке "Оружие", или перейдя прямо к нему из связанных объектов с единицей, найдите оружие вашего юнита (Рисунок 4)
Найдите у него поле "Стоимость +" (Рисунок 5)
Где "Основные показатели ^", измените "Энергия" на требуемое значение для каждой атаки(например 1) (Рисунок 6)
Нажмите ОК

Все готово, теперь при атаке юнит будет расходовать собственную энергию, а когда она закончится, он не сможет атаковать.
</value>
            </setting>
            <setting name="Module3_Vopros4" serializeAs="String">
                <value>Как поменять размер юнита?</value>
            </setting>
            <setting name="Module3_Otvet4" serializeAs="String">
                <value>В данных найдите своего юнита, которому хотите изменить размер (Рисунок 1)

Способ 1:
У него найдите агент(Рисунок 2) и свойство "Шкала" (Рисунок 3)
Чтобы понять как вам указать нужный размер, нужно понять как в ск2 выглядят проценты
1 - это означает 100%
0.1 - это означает 10%
0.01 - это означает 1%
Что касается размера юнита, то по умолчанию 100%, и если вы хотите изменить размер, то нужно указывать число после единицы или вместо единицы
Например:
2 - увеличение размера на 100%
1.1 - увеличение размера на 10%
1.01 - увеличение размера на 1%

Изменим размер на 100% (Рисунок 4)
Теперь морпех увеличился в 2 раза (Рисунок 5)

Способ 2:
У вашего юнита найдите основную модель (Рисунок 6)
Там найдите и измените поле "Минимальный масштаб" и "Максимальный масштаб" (Рисунок 7 и 8)
Готово.</value>
            </setting>
            <setting name="Module3_Vopros5" serializeAs="String">
                <value>Как сменить модель юнита?</value>
            </setting>
            <setting name="Module3_Otvet5" serializeAs="String">
                <value>Разместим на карте юнита, которому хотим изменить модель (Рисунок 1)

В данных найдем этого юнита (Рисунок 2)
Вариант 1:
У него откроем агент (Рисунок 3)
Найдем поля: Модель, Модель (постройка) и Модель (размещение) (Рисунок 4)
Таким способом вы можете изменить текущую модель на другую, со всеми настройками
Но для этого нужно понимать, какую именно модель нужно выбирать
Если вам нужна модель юнита, то чаще всего они будут иметь название без лишних частей
Например: Marine, Medivac, Mothership и тд.
Так же, в списке сортировки, вы можете указать тип "Unit" (Рисунок 5)
Но минус такого способа в том, что близзард наделали кучу типов, с конкетным названием юнита и вы можете не найти основную модель нужного юнита
Пример можно увидеть на Рисунке 6 и Рисунке 7

Укажем модель пилона(Рисунок 8) и укажем их в оставшиеся 2 поля(Рисунок 9)
Вы можете нажать Ctrl + C на первое поле и Ctrl + V на оставшиеся 2 поля
Теперь морпех у нас выглядит как пилон(Рисунок 10 и Рисунок 11)

Вариант 2:
Найдите у вашего юнита основную модель (Рисунок 12)
Найдите у нее поле "Модель" (Рисунок 13)
Открыв его, нажмите "Обзор" (Рисунок 14)
В списке найдите нужную модель (Рисунок 15)
Я указал в качестве примера модель крейсера (Рисунок 16)
Теперь морпех выглядит как крейсер (Рисунок 17 и Рисунок 18)</value>
            </setting>
            <setting name="Module1_Vopros0" serializeAs="String">
                <value>Все юниты вдруг начали летать, как это изменить?</value>
            </setting>
            <setting name="Module1_Otvet0" serializeAs="String">
                <value>Все юниты вдруг начали летать, как это изменить?

За это отвечает поле высот. Если оно настроенно не правильно, юниты будут "летать"
Я создал простую поверхность, чтобы показать как это работает (Рисунок 1-3)
Как видим, все нормально, юниты не "летают", а стоят на земле
Но если мы подведем морпеха в яму, то увидим что он стоит "на воздухе" (Рисунок 4)
По умолчанию базовая высота равна 8 единицам (Рисунок 5)
Посмотреть и изменить это значение можно в настройках карты (Рисунок 6)
Так же, чтобы понять какая именно высота вам нужна, нужно включить ее отображение на поверхности (Рисунок 7)
Теперь на повехности видим оранжевые полости, показывающие нам ниже какой высоты не может опуститься юнит (Рисунок 8)
Это можно изменить, просто убрав галку "Базовая высота для всех боевых единиц" (Рисунок 9)
Теперь юниты смогут спускаться в ямы, а не ходить "по воздуху"

Но это не решает проблему того, что юниты вдруг начали "летать"
Чтобы это исправить, нужно проверить чтобы базовая высота была равна 8 единицам, как это должно быть по умолчанию
Возможно, конкретно для вашей карты нужно будет другое значение и тут только эксперементировать
Перед тем, как изменять высоту, сохраните копию карты, так как измение высоты может привести к необратимому выравниванию поверхности

Теперь рассмотрим вариант по теме вопроса:
Изменим высоту например на 10 единиц и видим, что над поверхностью имеется оранжевый квадрат по всей карте
Теперь это минимальная высота для юнитов и это приводит к тому, что они летают (Рисунок 10)
Запустив игру, мы можем наблюдать следующую картину (Рисунок 11)
Все юниты, включая даже минералы, находятся "в воздухе"
Исправляем это изменением высоты до значения по умолчанию(то есть 8 единиц)

Готово.
Теперь вы знаете как работает поле высот и возможно решили свою проблему с "летающими" юнитами.</value>
            </setting>
            <setting name="Module2_Vopros4" serializeAs="String">
                <value>Как сменить скины юнитов?</value>
            </setting>
            <setting name="Module2_Otvet4" serializeAs="String">
                <value>Смена скинов происходит через действия триггеров

Для начала разместим несколько юнитов, для того, чтобы посмотреть что это работает (Рисунок 1)
Далее заходим в модуль Триггеров и выбираем созданный по умолчанию триггер "Инициализация схватки"
У него в действиях нужно создать "Apply Player Skin" (Рисунок 2)
Там есть просто "Apply Player Skin" и "Apply Player Skin (Peplacing Existing Unit)"
Apply Player Skin - применяет скин, но не заменяет модели у уже созданных на карте юнитов
Apply Player Skin (Peplacing Existing Unit) - делает тоже самое, только заменяет модели у уже созданных на карте юнитов

Создадим оба этих действия для наглядности (Рисунок 3)
Теперь выбираем любое из этих действий и где "No Game Link", мы можем указать конкетный скин 
(Рисунок 4)
Но проблема в том, что они все называются одинаково и если вам нужен один конкетный скин, его будет найти очень сложно
Например, на этой тестовой карте, я хочу использовать только гидралисков и гиблингов 
Чтобы их найти, придется буквально все скины перебирать по одному, чтобы найти нужный

Чтобы этого не делать, мы зайдем в модуль Данных и откроем там вкладку "Облики" из раздела "Герой" (Рисунок 5)
Теперь мы видим все доступные скины (Рисунок 6)
Далее мы просто нажимаем на любой из них и в свойтсвах ищем поле "Отобразить модель+"
В этом после написано имя юнита, которому будет заменена модель
Если вы все еще не можете понять что это за юнит, вы можете открыть поле "Значок вариаций" 
(Рисунок 8 и 9)

Теперь, чтобы нам упростить себе жизнь, мы можем добавать "Префикс редактора" или "Суффикс редактора"
Это нужно для того, чтобы в триггерах проще было найти нужный скин
Например, я добавлю "Префикс" на скин для гиблингов и гидралисков
(Префикс и Суффикс - это тоже свойсва, как и "Отобразить модель+")

Далее вернувшись в триггеры, я могу при помощи поиска легко найти нужные мне скины (Рисунок 10)
Установлю скины таким образом:
Apply Player Skin - Выберу там гиблингов
Apply Player Skin (Peplacing Existing Unit) - Выберу там гидралисков (Рисунок 11)

Запустив игру, мы можем видеть что у гиблингов скин не поменялся, а у гидралисков поменялся (Рисунок 12)
Это связно с тем, что гиблинги сразу есть на карте и скины будут применены только к новым, созданным юнитам (Рисунок 13)

Таким образом, мы выяснили что нужно использовать "Apply Player Skin (Peplacing Existing Unit)"
Так же, при смене скинов, нунжо указывать игрока(по умолчанию 1)
Если у вас на карте 10 игроков, то скины нужно применять для всех
Еще если вы хотите все скины, то их так же, все нужно указывать при помощи действий триггеров (Рисунок 14)
На скриншоте я указал не все, так как это просто пример

Теперь вариант, как можно все эти скины, применить ко всем 10-ти игрокам
Вы можете создать цикл, который сделает все за вас
Создадим "Pick Each Integer"(Рисунок 15) и поместим наши действия на смену скинов, в этот цикл (Рисунок 16)
Начало и конец цикла можно менять (Рисунок 17)
Теперь в наших действиях по смене скинов, где "Player 1", открываем, меняем на "Фукнкция" и указываем "Picked Integer" (Рисунок 18)
Теперь вы можете просто скопировать этот параметр для остальных действий (Рисунок 19 и 20)

Все готово.
Теперь вы знаете как менять скины и где их найти.</value>
            </setting>
            <setting name="Module11_Vopros0" serializeAs="String">
                <value>Как скачать и редактировать карту из игротеки?</value>
            </setting>
            <setting name="Module11_Otvet0" serializeAs="String">
                <value>Чтобы открыть карту опубликованные карты, нужно для начала нажать кнопку открытия карты (Рисунок 1)
Потом нужно переключиться на вкладку "Blizzard" и авторизоваться (Рисунок 2)
Там можно еще выбрать регион, но в теории, он сам его определит при авторизации
Если этого не произошло, попробуйте указать его вручную

Теперь вы можете указать "Источник" (Рисунок 3)
Выбрав один из источников, найдите в списке нужную карту, нажмите "Загрузить" и нажмите "ОК" (Рисунок 4)

Все готово, вы открыли опубликованную карту и можете ее редактировать.
При открытии опубликованных карт, есть нюанс, а именно: вы не можете открыть и редактировать "Закрытые карты"
Если нужная вам карта не находится по названию и последним сыгранным играм, возможно она закрыта для редактирования.
При публикации карты, каждый автор указывает, можно или нельзя ли будет редактировать его карту.
Так же, если вы являетесь автором этой карты и утратили исходники, то скорее всего тут ничего не поделать, так как даже собственные карты нельзя открывать таким способом.

Если вы хотите скачать какую-то свою карту, то можете использовать "Управление опубликованными материалами" (Рисунок 5)
Что представляет из себя почти тоже самое, только отображает карты, опубликованные вами.</value>
            </setting>
            <setting name="Module2_Vopros5" serializeAs="String">
                <value>Как сделать другого игрока союзником?</value>
            </setting>
            <setting name="Module2_Otvet5" serializeAs="String">
                <value>Зайдем в модуль Триггеров и откроем созданный по умолчанию триггер "Инициализация схватки"

Вариант 1: Самый простой
В действиях этого триггера, создадим "Set Allliance" (Рисунок 1)
Это действие позволяет задать союз между двумя игроками (Рисунок 2)
Где Source Player и Target Player можете указывать двух игроков, которые должны быть в союзе
Так же вы можете выбрать варианты союзов:
1) Просто союзники (без общего обзора)
2) Союзники с общим обзором
3) Союзники с общим обзором и контролем
4) Союзники с общим обзором и чем-то еще (не проверял)
5) Союзники с общим обзором, контролем и припасами/ресурсами(не точно)
6) Враги
7) Враги с общим обзором
8) Нейтралы
9) Нейтралы с общим обзором
10) Нейтралы с общим обзором и чем-то еще (не проверял)
(Рисунок 3)

Если на карте много игроков, такой способ будет не очень удобен, так как каждый игрок должен быть в союзе со всеми остальными игроками
Вам придется много раз копировать это действие и вручную указывать союзы для каждого игрока

Вариант 2: Сложнее, но удобнее
Будем использовать переменную для удобства добавления игроков
Так как союзы задаются в основном при старте карты, то использовать эту переменную как глобальную, нет смысла и по этому создадим ее как локальную
Нажимаем на "Local Variables" и нажимаем Ctrl + W (это создать новый элемент)
Созданную переменную назовем "Player Group" и укажем ей тип "Группа игрока" (Рисунок 4)
Далее создадим действие "Add Player To Player Group" (Рисунок 5 и 6)
Где Player Group нажимаем и выбираем нашу переменную "Player Group" (Рисунок 7)
Таким образом, копируем наше получившееся действие сколько нам нужно(например 4 раза) и меняем игроков (Рисунок 8)
Создадим действие "Set alliance For Player Group" (Рисунок 9)
Где Player Group нажимаем и выбираем нашу переменную

Все готово.
Теперь игроки будут союзниками.

Естественно, если у вас 15 игроков и вам нужно чтобы они были союзниками, то вы можете использовать цикл, для добавления всех игроков в группу.</value>
            </setting>
            <setting name="Module1_Vopros1" serializeAs="String">
                <value>Пропала/не отображается панель редактирования поверхности, как исправить?</value>
            </setting>
            <setting name="Module1_Otvet1" serializeAs="String">
                <value>Представим такую картину, что вы впервые открылили редактор или случайно что-то нажали и у вас не отображается панель редактирования поверхности (Рисунок 1)
Все, что вам нужно сделать, так это нажать кнопку "Вид" на верхней панели и снова включить "Показать панель интерфейса" (Рисунок 2)

Готово.
Теперь вы снова можете редактировать поверхность. (Рисунок 3)</value>
            </setting>
            <setting name="Module1_Vopros2" serializeAs="String">
                <value>Не отоборажаются кнопки редактирования поверхности, как исправить?</value>
            </setting>
            <setting name="Module1_Otvet2" serializeAs="String">
                <value>Представим такую картину, что вы впервые открылили редактор или случайно что-то сделали и у вас не отображаются кнопки редактирования поверхности (Рисунок 1)
Все, что вам нужно сделать, так это либо нажать на стрелки, либо навестись мышкой на одну из видимых кнопок и прокрутить колесико мыши вверх (Рисунок 2)

Готово.
Теперь вы снова можете редактировать поверхность. (Рисунок 3)</value>
            </setting>
            <setting name="Module3_Vopros6" serializeAs="String">
                <value>Как изменить цвет юнита?</value>
            </setting>
            <setting name="Module3_Vopros7" serializeAs="String">
                <value>Как изменить дальность оружия?</value>
            </setting>
            <setting name="Module3_Vopros8" serializeAs="String">
                <value>Как изменить скорость атаки оружия?</value>
            </setting>
            <setting name="Module3_Vopros9" serializeAs="String">
                <value>Как изменить урон оружия юнита?</value>
            </setting>
            <setting name="Module3_Otvet6" serializeAs="String">
                <value>Найдите юнита, которому вы хотите изменить цвет.
Откройте его Агент (Рисунок 1) и найдите поле "События+". (Рисунок 2)
Открыв события, нажмите ПКМ в любом свободном месте.
Из появившегося списка выберите "Добавить событие". (Рисунок 3)
Будет создано событие с прикрепленным к нему действием. (Рисунок 4)
Тип сообщения меняете на "Создание агента".
Далее выбираем действие и меняем его на "Задать оттенок".
В конце можно будет наглядно увидеть разницу между двумя юнитами.
Все параметры оставляете без изменений и указываете только нужный цвет и жмете ок.
После снова нажимаете ок и все готово. (Рисунок 8)
Рисунок 9 - Вид из редактора.
Рисунок 10 - Вид из игры.</value>
            </setting>
            <setting name="Module3_Otvet9" serializeAs="String">
                <value>Для того, что изменить урон оружия юнита, нужно для начала найти эффект урона, который наносит это оружие
Нажмите на оружие юнита и посмотрите, какой эффект указан в поле "Эффект" (Рисунок 1)
Так как у морпеха оружие не имеет снаряда, то у него в оружии сразу указан эффект урона (Рисунок 2)
Перейдя в этот эффект, найдите поле "Количество+"
У морпеха по умолчанию указано значение "6", это и есть урон его оружия
Вы можете менять это значение на любое другое

Вариант 2: Оружие со снарядом
Взяв в пример оружие мародера, видим что у него больше эффектов, связанных с его оружием (Рисунок 3)
Перейдя в его оружие, в поле эффекта, видим эффект запуска снаряда (Рисунок 5)
Теперь прейдем в эффект запуска снаряда, чтобы посмотреть с чем он еще связан (Рисунок 6)
Перейдем и в этот эффект и видим там эффект замедления и эффект насения урона (Рисунок 7)
Так мы последовательно выяснили какой именно эффект урона отвечает за его оружие
Это может быть полезно для юнитов, у которых несколько оружий или юнитов, которые используют оружие с несколькими уронами (Например, излучатель пустоты)</value>
            </setting>
            <setting name="Module3_Otvet8" serializeAs="String">
                <value>Для того, что изменить скорость атаки оружия юнита, нужно для начала перейти в его оружие
Нажмите на оружие юнита и найдите после "Интервал" (Рисунок 1)

У мародера по умолчанию 1.5 время между атаками
Вы можете менять это значение на любое другое

Готово.</value>
            </setting>
            <setting name="Module3_Otvet7" serializeAs="String">
                <value>Для того, что изменить дальность атаки оружия юнита, нужно для начала перейти в его оружие
Нажмите на оружие юнита и найдите после "Дальность" (Рисунок 1)

У мародера по умолчанию дальность 6
Вы можете менять это значение на любое другое

Готово.</value>
            </setting>
            <setting name="Module10_Vopros0" serializeAs="String">
                <value>Как сделать ботов по сложнее?</value>
            </setting>
            <setting name="Module10_Otvet0" serializeAs="String">
                <value>Чтобы изменить сложность ботов, зайдите для начала в настройки (Рисунок 1)
Перейдите во вкладку "Пробный запуск" и найдите "Сложность игры" (Рисунок 2)
Теперь вы можете изменить сложность ботов по умолчанию

Готово.</value>
            </setting>
            <setting name="Module2_Vopros6" serializeAs="String">
                <value>Как сделать смену дня и ночи?</value>
            </setting>
            <setting name="Module2_Otvet6" serializeAs="String">
                <value>Зайдите в Модуль триггеров и создайте новый триггер (Рисунок 1)
Создадим глобальную переменную, которая будет отвечать за День и Ночь 
Назовем ее "Day/Night", укажем тип "Булево" и начальное значение поменяем на "Истина"(Рисунок 2)
Определять будем так:
Истина - это день
Ложь - это ночь

Вернемя в триггер и создадим событие "Map initialization", которое будет выбрано по умолчанию сразу и сработает, как только карта загрузится (Рисунок 3)
Переходим сразу к действиям и создадим бесконечный цикл, который и будет запускать смену дня и ночи
Сделаем каркас для смены для и ночи, а потом сделаем отображения таймера

Создаем действие "Repeat Forever" (Рисунок 4)
В действиях этого цикла создадим "Wait" и укажем в него время, сколько будет идти день
В качестве примера укажу 30 секунд (Рисунок 5)
Так как у нас по умолчанию День и этот триггер сработает при старте карты, то ему нужно только ждать наступление ночи

После Wait создадим действие "Set Lighting" (Рисунок 6)
Где Light - укажем какое-нибудь освещение карты для ночи
Где Blend Time - время, в течении которого применится это освещение (Рисунок 7) (Со временем эксперементируйте)
Чтобы понять, какое освещение вам больше подходит, вы можете посмотреть их в отдельном окне "Освещение" (Рисунок 8, 9 и 10)
Так же можете посмотреть вопрос "Как сменить освещение карты?", чтобы более подробно об этом узнать

Теперь после "Set Lighting" создадим действие "Set Variable" (Рисунок 11)
Где Variable - Укажем нашу переменную (Рисунок 12)
Где Value - Откроем и просто нажмем "Ок", без установки галки на "Истина" (Рисунок 13)
Это мы сделали смену на ночь

Теперь сделаем смену на день
Скоприуем "Wait" и вставим его после "Set Value" (Рисунок 14)
Значение в этом ожидании, будет означать сколько длится ночь
Скоприуем так же "Set Light" и вставим его после "Wait" 
Как и в прошлый раз, изменим освещение на дневное (в моем случае это Argia) (Рисунок 15)
Скоприуем "Set Variable" и изменим заначение "Flalse" на "Истина" (Рисунок 16)

Каркас для смены дня и ночи готов.
Теперь можно прикрутить сюда таймер, для отображения длительности дня и ночи.

Создадим одну локальную переменную, назовем ее "Time of Day" и укажем тип "Таймер" (Рисунок 17)
Тут же, сразу создадим переменную, для отображения нашего таймера
Создаем еще одну локальную переменную, назовем ее "Timer Window" и укажем тип "Timer Window" (Рисунок 18)

Теперь в цикле, перед ожиданием для ночи, создадим действие "Start Timer" (Рисунок 19)
Где Timer - Открываем и указываем нашу переменную "Time of Day"
Где One Shot - Оставляем без изменений
Где Duration - Укажем сколько времени осталось до наступления ночи
В моем случае это 30 секунд

После создаем "Set Variable"
Где Variable - Укажем нашу переменную таймера "Time of Day" (Рисунок 20)
Где Value - Откроем, переключим на "функция" и укажем "Last Started Timer" (Рисунок 21)

Создадим следующее действие "Create Timer Window" (Рисунок 22)
Где Last Started Timer - Откроем, переключим на "Переменная" и укажем нашу переменную "Time of Day"
Где Title - Можете написать что-то вроде "День" (Рисунок 23)

Так же, после этого создадим действие "Set Variable"
Где Variable - Укажем нашу переменную "Timer Window"
Где Value - Откроем, переключим на "функция" и укажем "Last Created Timer Window" (Рисунок 24)

Теперь 4 действия, связанные с таймером скопируйте и вставьте после наступления ночи
То есть после "Set Variable" со значением "False" (Рисунок 25)
В "Create Timer Window" измените текст "День", на "Ночь"
В "Start Timer" измените время на то, сколько у вас длится ночь (Рисунок 26)

Уже в процессе добавления вопроса, заметил что забыл дописать одну строку, из-за которой у вас с каждым новым днем или ночью, будет создаваться новое окно с таймером
Это не правильно, он должен удалять старый и создавать новый
Вам нужно только добавить 2 действия "Destroy Timer Window" и указать туда переменную "Timer Window"
Разместить их перед действием "Create Timer Window"
Рисунок я добавил в самый конец (Рисунок 33)

Все готово.
Теперь у вас будет смена дня и ночи.

Такой способ очень простой и без лишних заморочек.
Если вы хотите привязать какие-то события на срабатывание таймера дня и ночи, то переменную "Time of Day" вам нужно будет просто перенести из локальных, в глобальные.
Потому что если переменная локальная, то вы не сможете получить к ней доступ из других триггеров.

Вот как перенести ее:
Скоруйте ее, нажмите на любой триггер или глобальную переменную и вставьте (Рисунок 27 и 28)
Вернитесь в триггер, нажмите на локальную версию этой переменной и нажмите "Delete" (Рисунок 29)
Он вам покажет что она задействована N кол-во раз
Нажимаем "Ок" и видим что везде, где она использовалась, подсвечивает красным (Рисунок 30)
Теперь просто вручную указываем нашу глобальную переменную (Рисунок 31 и 32)

Но с точки зрения удобства, это не очень правильно.
Вы можете использовать нажать на локальную переменную и нажать Ctrl + F10, чтобы посмотерть где она используется.
Так же, вы можете нажимать двойным кликом и переходить в конктреное место, к конкретному действию или функции, где используется переменная.
Это будет более правильно и более удобно.
На скришотах я показал вариант, когда триггер не большой и переменная почти нигде не используется.

Готово.
Теперь вы перенесли локальную переменная в глобальные и подставили ее везде, где она использовалась.
Так вы сможете использовать ее в других триггерах.</value>
            </setting>
            <setting name="Module2_Vopros7" serializeAs="String">
                <value>Как сделать телепорт юнитов из одной точки в другую?</value>
            </setting>
            <setting name="Module2_Otvet7" serializeAs="String">
                <value>Создадим простую карту, для демонстрации (Рисунок 1)
Разместим 2 маяка и создадим 2 области прямо на этих маяках (Рисунок 2)
Разместим 2 точки рядом с маяками (Рисунок 3)
Изменим обоим маякам владельца на нейтрального (Рисунок 4)

Зайдем в Модуль Триггеров
Создадим новый триггер и назовем его "Teleport" (Рисунок 5)
Создадим событие "Unit Enters/Leaves Region" (Рисунок 6)
Где Region - Открываем, переключаем на "Значение" и выбираем одну из областей (Рисунок 7)
Скопируем это событие и укажем в нем вторую область (Рисунок 8)

Переходим к условиям и создадим новый элемент (Ctrl + W)(Рисунок 9)
Где Operator - Изменим значение на "!=" 
Где Value 2 - Изменим значение на ноль (Рисунок 10)

Переходим к действиям и создадим действие "If then Else-if" (Рисунок 11)
Создадим в нем новый элемент (Рисунок 12)
В первом из этих элементов создадим условие (Рисунок 13)
Где Value 1 - Укажем "Triggering Region"
Где Value 2 - Укажем одну из областей (Рисунок 14)

Далее где Then создадим действие "Move Unit Instantly" (Рисунок 15)
Где Point - Укажем точку на противоположной стороне от области, которую вы указали в условии (Рисунок 16)

Скопируем получившееся условие (Рисунок 17)
Теперь в условии изменим область и в действии поменяем точку (Рисунок 18)

Все готово.
Теперь у вас есть телепорт юнитов.

Таким способом вы сможете при желании добавлять новые области и точки для телепорта
Что касается размещения точек рядом с маяком, а не прямо на маяке, это для того, чтобы юнит зайдя на маяк, не начинал бесконечно телепортироваться с одного маяка на другой
Это можно изменить, придумав способ, благодаря которому один и тот же юнит, не сможет телепортироваться в течении нескольких секунд
Либо пока не сойдет с маяка и не зайдет на него снова</value>
            </setting>
            <setting name="Module2_Vopros8" serializeAs="String">
                <value>Как сделать волны врагов из точки в точку?</value>
            </setting>
            <setting name="Module2_Otvet8" serializeAs="String">
                <value>Заходим в модуль Триггеров

Рассмотрим 2 варианта:
Вариант 1: Спавн юнита в точке, приказ атаки напрямую, в конечную точку
Вариант 2: Тоже самое, только приказ атаки через ряд точек

Я создам простую поверхность для демонтарции (Рисунок 1)
Откроем триггер "Инициализация схватки" и так как у меня карта чистая, удалим находящиейся в нем действия (Не обязательно)(Рисунок 2)
Создадим в нем действие "Reveal Area"(Рисунок 3) и изменим у него:
Где Area - Нажимаем, переключаем на "Функция" и указываем "Entire map" (Рисунок 4)
Где Duration - Меняем на ноль (Рисунок 5)
(Это действие было не обязательно, оно нужно только для демонстрации)

Вариант 1:
Предположим, что мы хотим сделать такой вариант, когда зерглинги будут бежать из точки 001 в точку 002
Создадим новый триггер (Ctrl + T) (Рисунок 6)
Предположим, что зерглинги будут спавниться через 5 сек. после старта карты
В конце я покажу как сделать чтобы волны атак увеличивались и сделать их периодическими

Создадим событие "Time Elapsed"(Рисунок 7)
Создадим действие "Create units Facing Angle"(Рисунок 8) и изменим у него:
Где Type - Открываем, пишем в поиске "Зерглинг" и выставляем нужные фильтры, которые отсеят ненужных юнитов (Рисунок 9)
Где Point - Открываем и указываем точку 001 (Рисунок 10)

Далее создадим действие "Issue Order" (Рисунок 11) и изменим у него:
Где Unit - Открываем и через поиск находим "Last Created Unit" (Рисунок 12)
Важно: если создаете больше 1 юнита, то тут нужно другое действие
А именно "Issue Order To Unit Group" и где "Group", вы укажете "Last Created Units"
Где Order - Открываем и меняем на "Order Targeting Point" (Рисунок 13)
Где Ability Command - Открываем и указываем "Атаковать" (Рисунок 14)
Где Target Point - Открываем и указываем точку 002

Где Queue - Оставляем без изменений

Готово.
Запускаем карту и видим следующее:
Зерглинг заспавнился и бежит по прямой из точки 001 в точку 002 (Рисунок 16 и 17)
Минус такого способа в том, что если вам нужно чтобы юниты шли через ряд точек, то они будут их игнорировать и идти по кратчайшему пути в конечную точку

Вариант 2:
Изменим действие "Issue Order"
Где Target Point: Точка 002 - Изменим на точка 003 или точка 004(на ваше усмотрение)(Рисунок 18)

Скопируем и вставим это действие еще раз (Рисунок 19)
Где Queue - Изменим на "After Existing Orders", что означает "После всех приказов" (Рисунок 20)
Где Target Point - Изменим на точку 002 (Рисунок 21)
Для справки: "Replace Existing Orders" означает "Заменить текущие приказы"; "After Existing Orders" означает "После всех приказов"; "Before Existing Orders" не знаю)) никогда не пользовался

Готово.
Запускаем карту и видим следующее:
Зерглинг заспвнился и бежит по краю карты в конечную точку(Рисунок 21 и 22)

Теперь рассмотрим вариант, когда волны атак будут увеличиваться
Изменим событие триггера на "Periodic Event" и укажем к примеру 10 сек. (Рисунок 23)
Изменим в действии "Create Unit Facing Angle", параметр "Count" на 5 (Рисунок 24)
Удалим оба действия "Issue Order" (Рисунок 25)
Создадим действие "Issue Order To Unit Group" (Рисунок 26)
Где Group - Изменим на "Last Created Units" (Рисунок 27)
Где Order - Как и предыдущих вариантах, указываем "Order Targeting Point"
Где Ability Command - Указываем "Атаковать"
Где Target Point - Указываем первую точку пути, которая в моем случае будет точка 003 (Рисунок 28)

Скопируем и вставим это действие еще раз
Где Точка 003 - Изменим на конечную точку(Точка 002). Вы так же можете указывать следующую точку пути.
Где Queue - Изменим на "After Existing Orders" (Рисунок 29)

Почти готово.
Вы можете теперь запустить карту и посмотреть как зерглинги будут спавниться и бежать через ряд точек.

Теперь добавим счетчик, который будет увеличивать кол-во зерглингов
Создадим глобальную переменную(Ctrl + B) Units(Рисунок 30)
Тип переменной оставляем без изменений(Целое число)
Изменим ей только начальное значение на 5 ед. (Рисунок 31)
Это будет означать, что по умолчанию у нас будет спавниться 5 зерглингов

Вернемся в наш триггер и в действии "Create Units Facing Angle", изменим число на нашу переменную
Для этого нажмите на пятерку, переключите на "Переменная" и укажите нашу переменную (Рисунок 32)

Теперь после всех действий, в конце создадим действие "Modify Variable (Integer)" (Рисунок 33)
Где Variable - Указываем нашу переменную
Где Value - Указываем число, на которое будет увеличиваться кол-во зерглингов после каждого спавна
(Рисунок 34)

Все готово.
Теперь вы знаете как сделать волны атак с постоянным увеличением создаваемых юнитов.</value>
            </setting>
        </SC2MapEdtiorXeXxD.Properties.Settings>
        <SC2MapEdtiorXeX.Properties.Settings>
            <setting name="Module2_Otvet0" serializeAs="String">
                <value>Создаем новый триггер (Рисунок 1)
В нем создаем событие Chat Message (Рисунок 2)
Создав его, мы видим параметры, которое может принимать это событие (Рисунок 3)
Далее где Text: вписываете команду, на которую будет срабатывать триггер

Теперь создаем локальную переменную, называем ее Units (название может быть любым) и указываем ей тип "группа единиц" (Рисунок 4)
Создаем действие Set Varialbe (Рисунок 5)
Где Varible, указываем свою переменную Units (Рисунок 6)
Где Value, указываем: функция - Selected Units (Рисунок 7)
Где Player, указываем Triggering Player (Рисунок 8)

Далее создаем действие Pick Each Unit In Unit Group (Рисунок 9)
Где Unit Group, указываем нашу переменную Units (Рисунок 10)

Теперь тут же создаем действие If Then Else (Рисунок 11)
Где if создаем новый элемент(по умолчанию сравнение)(Ctrl + W) (Рисунок 12)
Где Value 1: Owner of Unit есть параметр Unit
В него указываем Picked Unit (Рисунок 13)
Где Value 2: Меняем на Triggering Player (Рисунок 14)
Далее в Then создаем действие Kill Unit (Рисунок 15)
Triggering Unit меняем на Picked Unit (Рисунок 16)

Готово.
Триггер на убийство юнитов при вводе команды чат готов.</value>
            </setting>
            <setting name="Module3_Vopros0" serializeAs="String">
                <value>Начало работы с модуем данных</value>
            </setting>
            <setting name="Module3_Vopros1" serializeAs="String">
                <value>Как сделать чтобы за убийство давались ресурсы?</value>
            </setting>
            <setting name="Module3_Otvet1" serializeAs="String">
                <value>Открыв вкладку "Единицы" найдите там юнита, за убийство которого будут даваться ресурсы.
Найдите поле "Уничтожить ресурс+" и открыв его, вы можете указать до 4х разных ресурсов.
Указывайте нужно количество и жмите ок.
Готово.</value>
            </setting>
            <setting name="Module3_Otvet0" serializeAs="String">
                <value>Для начала работы с модулем даныых, выставьте настройки таким образом (Рисунок 1)
Чтобы находить любые нужные данные, вы можете открывать и добавлять себе любые доступные вкладки (Рисунок 2)

Это нужно для того, чтобы при просмотре ответов на вопросы по модулю данных, у вас не возникали вопросы, с непониманием того, почему у меня что-то отображается, а у вас нет

Например, чтобы вы так же легко могли открыть агент любого юнита или любой другой объект, связанный с юнитом

Готово.</value>
            </setting>
            <setting name="Module2_Vopros0" serializeAs="String">
                <value>Как сделать убийство выбранного юнита при вводе команды в чат?</value>
            </setting>
            <setting name="Module2_Vopros1" serializeAs="String">
                <value>Какой ивент в триггерах делает что-бы после наступления определенного времени, происходило какое-нибудь действие?</value>
            </setting>
            <setting name="Module2_Otvet1" serializeAs="String">
                <value>За это отвечает событие "Time Elapsed" и "Periodic Event"
Находятся они по метке "Time" (Рисунок 1)

Вариант 1: Time Elapsed
Это событие отвечает за "Время прошло" и запускается один раз
Можно указывать время в секундах и тип времени (Рисунок 2)

Добавив вывод сообщения со временем миссии в чат, увидим такую картину (Рисунок 3)

Вариант 2: Periodic Event
Это событие отвечает за периодические события и запускается бесконечное кол-во раз
Так же можно указывать время в секундах и тип времени (Рисунок 4)

Добавив вывод сообщения со временем миссии в чат, увидим такую картину (Рисунок 5)

Готово.
Теперь вы знаете как это работает.</value>
            </setting>
            <setting name="Module2_Vopros2" serializeAs="String">
                <value>Как сделать подъем и спад лавы? + урон от лавы</value>
            </setting>
            <setting name="Module2_Otvet2" serializeAs="String">
                <value>Создадим простой рельеф для поднятия лавы (Рисунок 1)
Добавим лаву (Рисунок 2)
Откроем настройки воды (Рисунок 3)
Добавим новое состояние воды и сделаем цвет такой же как в "По умолчанию" 
Так же укажем нужну нам высоту для поднятой лавы. (Рисунок 4)
Зайдем в триггеры и создадим триггер, отвечающий за подъем и спад лавы. (Рисунок 5)
Создадим событие Pereodic Event и укажем время, через которое будет подниматься лава. (Рисунок 6)
Создадим устловие (If) (Рисунок 7)
Создадим глобальную переменную Lava Up/Down с типом "Булево" (Рисунок 8)
В условии будем проверять эту переменную со значением False (Рисунок 9)
В then создадим действие Play Sound и укажем туда звук TUIlavaRising (Рисунок 10)
Создадим действие Set Water State (Рисунок 11)
Где state укажем созданное ранее состояние воды (Рисунок 12)
Где over 1.0 secodns укажем 4 сек.
Далее создадим действие Wait для того, чтобы лава чисто визуально поднялась до нужного уровня,
ниже которого юниты будут получать урон. (Рисунок 13)
Далее создадим действие Turn Trigger On/Off
Где Off меняем на On
Current Trigger пока оставляем как есть (Рисунок 14)
После создадим действие Set Variable 
Где Variable укажем нашу переменную "Lava"
Где Value укажем "Истина" (Рисунок 15)

Теперь в Else скопируем действия:
Play Sound + Set Water State + Wait + Trigger On/Off + Set Variable (Рисунок 16)
Двух секундную задержку в действии Wait меняем на 1.5 сек.
В Set Variable "Истина" меняем на "Ложь", просто убрав галку(Рисунок 17)
В Set Water State меняем состояние на "По умолчанию" (Рисунок 18)
В Trigger On/Off параметр "On" меняем на "Off" (Рисунок 19)

Дальше нужно создать триггер, который будет наносить урон юнитам в лаве
Создадим триггер Lava Damage
Нажимаем на него ПКМ и убираем галку "Изначально включен" (Рисунок 20)
Добавим в него событие "Periodic Event" и установим параметр "Duration" на значение "0.5" (Рисунок 21)
Далее в условии триггера добавим условие(просто crtl + w + enter)
Где Value 1 укажем "Trigger Is On"
Где Value 2 укажем "Истина" (Рисунок 22)
Далее в действиях создаем "Pick Each Unit In Unit Group"(Рисунок 23)
Параметр Unit Group меняем на "Units In Unit group Matching Condition" (Рисунок 24)
Где Unit Filter открываем и двойным кликом меняем "Тип" "Воздушный" и "Неуязвимый" на "Исключено"
Так же снимаем галки "Союзник" и "Противник" (Рисунок 25)
Далее в Actions создаем проверку (If) (Рисунок 26)
Где If создадим устловие. В этом в условии:
Где Value 1 поменяем на Height At Point (Рисунок 27)
Где Unit меняем на Picked Unit (Рисунок 28)
Где Operator меняем на &lt;= (Меньше или равно)
Где Value 2 указываем значение, которое чуть меньше чем высота поднятой лавы. (Рисунок 29)
Это нужно для того, чтобы юниты получали урон зайдя в лаву, а не приблизившись к ней.
Далее в Then добавим действие Add Behavior (Player) (Рисунок 30)
Где Behavior укажем "Лава (урон)" (Рисунок 31)
Где Unit укажем Picked Unit (Рисунок 32)
Где Player укажем 15
Триггер на получение урона готов. (Рисунок 33)

Теперь нужно вернуться в триггер, который поднимает и опускает лаву.
В нем в обоих Trigger On/Off, где "Current Trigger" меняем на наш триггер получения урона.
(Рисунок 34)

Готово.</value>
            </setting>
            <setting name="Module3_Vopros2" serializeAs="String">
                <value>Как добавить на карту всех юнитов (протосов-подвиды талдаримы, неразимы и т.д и другие расы)?</value>
            </setting>
            <setting name="Module3_Otvet2" serializeAs="String">
                <value>При создании карты, указывайте карту игротеки или модификацию (Рисунок 1)
Вы можете нажать "стадрат", выбрать нужную кампанию и установить галку "данные кампании" (Рисунок 2)
Но со временем я выянил, что он не всегда включает все данные, всех трех кампаний и по этому сделаем по-другому
Нажимаем "По выбору" (Рисунок 3)
Нажимаем "Стандарт" и указываем галки всех трех кампаний + по желанию Nova (Рисунок 4)
Не указываем "Сетевой режим" вместе с ресурсами кампании, так как они будут конфликтовать
В итоге получится такой список (Рисунок 5)
Теперь нам доступны юниты из всех кампаний (Рисунок 6)</value>
            </setting>
            <setting name="Module2_Vopros3" serializeAs="String">
                <value>Как сменить освещение на карте?</value>
            </setting>
            <setting name="Module2_Otvet3" serializeAs="String">
                <value>Для начала можете открыть отдельное окно со всеми освещениями (Рисунок 1 и Рисунок 2)
Это может быть полезно для того, чтобы посмотреть как на вашей карте будет выглядеть конкретное освещение
Варианты освещения можно нажимать и смотреть (Рисунок 3 и Рисунок 4)

Чтобы применить понравившееся, нужно в модуле триггеров, создать действие "Set lighting" (Рисунок 5)
Где Light - указываете освещение (Рисунок 6)
Где Blend Time - указываете время, в течении которого применится освещение (Рисунок 7)
Если указать 0, то оно будет применено мгновенно

Освещение обратно не сменится, пока вы сами не создадите действие триггеров, на примение другого освещения карты.
Готово.</value>
            </setting>
            <setting name="Module3_Vopros3" serializeAs="String">
                <value>Как сделать так что-бы за каждый выстрел (например морпеха) тратилась 1 единица энергии?</value>
            </setting>
            <setting name="Module3_Otvet3" serializeAs="String">
                <value>В данных, во вкладке "Единицы", найдите юнита, которому вы хотите сделать атаку за энергию(Рисунок 1)
Измените ему поле "Начальный запас энергии" и "Максимальное кол-во энергии" на нужное вам заначение(например 10) (Рисунок 2 и 3)
Проверье, чтобы "Скорость восстановления энергии была равна нулю" (Рисунок 3)
Далее во вкладке "Оружие", или перейдя прямо к нему из связанных объектов с единицей, найдите оружие вашего юнита (Рисунок 4)
Найдите у него поле "Стоимость +" (Рисунок 5)
Где "Основные показатели ^", измените "Энергия" на требуемое значение для каждой атаки(например 1) (Рисунок 6)
Нажмите ОК

Все готово, теперь при атаке юнит будет расходовать собственную энергию, а когда она закончится, он не сможет атаковать.
</value>
            </setting>
            <setting name="Module3_Vopros4" serializeAs="String">
                <value>Как поменять размер юнита?</value>
            </setting>
            <setting name="Module3_Otvet4" serializeAs="String">
                <value>В данных найдите своего юнита, которому хотите изменить размер (Рисунок 1)

Способ 1:
У него найдите агент(Рисунок 2) и свойство "Шкала" (Рисунок 3)
Чтобы понять как вам указать нужный размер, нужно понять как в ск2 выглядят проценты
1 - это означает 100%
0.1 - это означает 10%
0.01 - это означает 1%
Что касается размера юнита, то по умолчанию 100%, и если вы хотите изменить размер, то нужно указывать число после единицы или вместо единицы
Например:
2 - увеличение размера на 100%
1.1 - увеличение размера на 10%
1.01 - увеличение размера на 1%

Изменим размер на 100% (Рисунок 4)
Теперь морпех увеличился в 2 раза (Рисунок 5)

Способ 2:
У вашего юнита найдите основную модель (Рисунок 6)
Там найдите и измените поле "Минимальный масштаб" и "Максимальный масштаб" (Рисунок 7 и 8)
Готово.</value>
            </setting>
            <setting name="Module3_Vopros5" serializeAs="String">
                <value>Как сменить модель юнита?</value>
            </setting>
            <setting name="Module3_Otvet5" serializeAs="String">
                <value>Разместим на карте юнита, которому хотим изменить модель (Рисунок 1)

В данных найдем этого юнита (Рисунок 2)
Вариант 1:
У него откроем агент (Рисунок 3)
Найдем поля: Модель, Модель (постройка) и Модель (размещение) (Рисунок 4)
Таким способом вы можете изменить текущую модель на другую, со всеми настройками
Но для этого нужно понимать, какую именно модель нужно выбирать
Если вам нужна модель юнита, то чаще всего они будут иметь название без лишних частей
Например: Marine, Medivac, Mothership и тд.
Так же, в списке сортировки, вы можете указать тип "Unit" (Рисунок 5)
Но минус такого способа в том, что близзард наделали кучу типов, с конкетным названием юнита и вы можете не найти основную модель нужного юнита
Пример можно увидеть на Рисунке 6 и Рисунке 7

Укажем модель пилона(Рисунок 8) и укажем их в оставшиеся 2 поля(Рисунок 9)
Вы можете нажать Ctrl + C на первое поле и Ctrl + V на оставшиеся 2 поля
Теперь морпех у нас выглядит как пилон(Рисунок 10 и Рисунок 11)

Вариант 2:
Найдите у вашего юнита основную модель (Рисунок 12)
Найдите у нее поле "Модель" (Рисунок 13)
Открыв его, нажмите "Обзор" (Рисунок 14)
В списке найдите нужную модель (Рисунок 15)
Я указал в качестве примера модель крейсера (Рисунок 16)
Теперь морпех выглядит как крейсер (Рисунок 17 и Рисунок 18)</value>
            </setting>
            <setting name="Module1_Vopros0" serializeAs="String">
                <value>Все юниты вдруг начали летать, как это изменить?</value>
            </setting>
            <setting name="Module1_Otvet0" serializeAs="String">
                <value>Все юниты вдруг начали летать, как это изменить?

За это отвечает поле высот. Если оно настроенно не правильно, юниты будут "летать"
Я создал простую поверхность, чтобы показать как это работает (Рисунок 1-3)
Как видим, все нормально, юниты не "летают", а стоят на земле
Но если мы подведем морпеха в яму, то увидим что он стоит "на воздухе" (Рисунок 4)
По умолчанию базовая высота равна 8 единицам (Рисунок 5)
Посмотреть и изменить это значение можно в настройках карты (Рисунок 6)
Так же, чтобы понять какая именно высота вам нужна, нужно включить ее отображение на поверхности (Рисунок 7)
Теперь на повехности видим оранжевые полости, показывающие нам ниже какой высоты не может опуститься юнит (Рисунок 8)
Это можно изменить, просто убрав галку "Базовая высота для всех боевых единиц" (Рисунок 9)
Теперь юниты смогут спускаться в ямы, а не ходить "по воздуху"

Но это не решает проблему того, что юниты вдруг начали "летать"
Чтобы это исправить, нужно проверить чтобы базовая высота была равна 8 единицам, как это должно быть по умолчанию
Возможно, конкретно для вашей карты нужно будет другое значение и тут только эксперементировать
Перед тем, как изменять высоту, сохраните копию карты, так как измение высоты может привести к необратимому выравниванию поверхности

Теперь рассмотрим вариант по теме вопроса:
Изменим высоту например на 10 единиц и видим, что над поверхностью имеется оранжевый квадрат по всей карте
Теперь это минимальная высота для юнитов и это приводит к тому, что они летают (Рисунок 10)
Запустив игру, мы можем наблюдать следующую картину (Рисунок 11)
Все юниты, включая даже минералы, находятся "в воздухе"
Исправляем это изменением высоты до значения по умолчанию(то есть 8 единиц)

Готово.
Теперь вы знаете как работает поле высот и возможно решили свою проблему с "летающими" юнитами.</value>
            </setting>
            <setting name="Module2_Vopros4" serializeAs="String">
                <value>Как сменить скины юнитов?</value>
            </setting>
            <setting name="Module2_Otvet4" serializeAs="String">
                <value>Смена скинов происходит через действия триггеров

Для начала разместим несколько юнитов, для того, чтобы посмотреть что это работает (Рисунок 1)
Далее заходим в модуль Триггеров и выбираем созданный по умолчанию триггер "Инициализация схватки"
У него в действиях нужно создать "Apply Player Skin" (Рисунок 2)
Там есть просто "Apply Player Skin" и "Apply Player Skin (Peplacing Existing Unit)"
Apply Player Skin - применяет скин, но не заменяет модели у уже созданных на карте юнитов
Apply Player Skin (Peplacing Existing Unit) - делает тоже самое, только заменяет модели у уже созданных на карте юнитов

Создадим оба этих действия для наглядности (Рисунок 3)
Теперь выбираем любое из этих действий и где "No Game Link", мы можем указать конкетный скин 
(Рисунок 4)
Но проблема в том, что они все называются одинаково и если вам нужен один конкетный скин, его будет найти очень сложно
Например, на этой тестовой карте, я хочу использовать только гидралисков и гиблингов 
Чтобы их найти, придется буквально все скины перебирать по одному, чтобы найти нужный

Чтобы этого не делать, мы зайдем в модуль Данных и откроем там вкладку "Облики" из раздела "Герой" (Рисунок 5)
Теперь мы видим все доступные скины (Рисунок 6)
Далее мы просто нажимаем на любой из них и в свойтсвах ищем поле "Отобразить модель+"
В этом после написано имя юнита, которому будет заменена модель
Если вы все еще не можете понять что это за юнит, вы можете открыть поле "Значок вариаций" 
(Рисунок 8 и 9)

Теперь, чтобы нам упростить себе жизнь, мы можем добавать "Префикс редактора" или "Суффикс редактора"
Это нужно для того, чтобы в триггерах проще было найти нужный скин
Например, я добавлю "Префикс" на скин для гиблингов и гидралисков
(Префикс и Суффикс - это тоже свойсва, как и "Отобразить модель+")

Далее вернувшись в триггеры, я могу при помощи поиска легко найти нужные мне скины (Рисунок 10)
Установлю скины таким образом:
Apply Player Skin - Выберу там гиблингов
Apply Player Skin (Peplacing Existing Unit) - Выберу там гидралисков (Рисунок 11)

Запустив игру, мы можем видеть что у гиблингов скин не поменялся, а у гидралисков поменялся (Рисунок 12)
Это связно с тем, что гиблинги сразу есть на карте и скины будут применены только к новым, созданным юнитам (Рисунок 13)

Таким образом, мы выяснили что нужно использовать "Apply Player Skin (Peplacing Existing Unit)"
Так же, при смене скинов, нунжо указывать игрока(по умолчанию 1)
Если у вас на карте 10 игроков, то скины нужно применять для всех
Еще если вы хотите все скины, то их так же, все нужно указывать при помощи действий триггеров (Рисунок 14)
На скриншоте я указал не все, так как это просто пример

Теперь вариант, как можно все эти скины, применить ко всем 10-ти игрокам
Вы можете создать цикл, который сделает все за вас
Создадим "Pick Each Integer"(Рисунок 15) и поместим наши действия на смену скинов, в этот цикл (Рисунок 16)
Начало и конец цикла можно менять (Рисунок 17)
Теперь в наших действиях по смене скинов, где "Player 1", открываем, меняем на "Фукнкция" и указываем "Picked Integer" (Рисунок 18)
Теперь вы можете просто скопировать этот параметр для остальных действий (Рисунок 19 и 20)

Все готово.
Теперь вы знаете как менять скины и где их найти.</value>
            </setting>
            <setting name="Module11_Vopros0" serializeAs="String">
                <value>Как скачать и редактировать карту из игротеки?</value>
            </setting>
            <setting name="Module11_Otvet0" serializeAs="String">
                <value>Чтобы открыть карту опубликованные карты, нужно для начала нажать кнопку открытия карты (Рисунок 1)
Потом нужно переключиться на вкладку "Blizzard" и авторизоваться (Рисунок 2)
Там можно еще выбрать регион, но в теории, он сам его определит при авторизации
Если этого не произошло, попробуйте указать его вручную

Теперь вы можете указать "Источник" (Рисунок 3)
Выбрав один из источников, найдите в списке нужную карту, нажмите "Загрузить" и нажмите "ОК" (Рисунок 4)

Все готово, вы открыли опубликованную карту и можете ее редактировать.
При открытии опубликованных карт, есть нюанс, а именно: вы не можете открыть и редактировать "Закрытые карты"
Если нужная вам карта не находится по названию и последним сыгранным играм, возможно она закрыта для редактирования.
При публикации карты, каждый автор указывает, можно или нельзя ли будет редактировать его карту.
Так же, если вы являетесь автором этой карты и утратили исходники, то скорее всего тут ничего не поделать, так как даже собственные карты нельзя открывать таким способом.

Если вы хотите скачать какую-то свою карту, то можете использовать "Управление опубликованными материалами" (Рисунок 5)
Что представляет из себя почти тоже самое, только отображает карты, опубликованные вами.</value>
            </setting>
            <setting name="Module2_Vopros5" serializeAs="String">
                <value>Как сделать другого игрока союзником?</value>
            </setting>
            <setting name="Module2_Otvet5" serializeAs="String">
                <value>Зайдем в модуль Триггеров и откроем созданный по умолчанию триггер "Инициализация схватки"

Вариант 1: Самый простой
В действиях этого триггера, создадим "Set Allliance" (Рисунок 1)
Это действие позволяет задать союз между двумя игроками (Рисунок 2)
Где Source Player и Target Player можете указывать двух игроков, которые должны быть в союзе
Так же вы можете выбрать варианты союзов:
1) Просто союзники (без общего обзора)
2) Союзники с общим обзором
3) Союзники с общим обзором и контролем
4) Союзники с общим обзором и чем-то еще (не проверял)
5) Союзники с общим обзором, контролем и припасами/ресурсами(не точно)
6) Враги
7) Враги с общим обзором
8) Нейтралы
9) Нейтралы с общим обзором
10) Нейтралы с общим обзором и чем-то еще (не проверял)
(Рисунок 3)

Если на карте много игроков, такой способ будет не очень удобен, так как каждый игрок должен быть в союзе со всеми остальными игроками
Вам придется много раз копировать это действие и вручную указывать союзы для каждого игрока

Вариант 2: Сложнее, но удобнее
Будем использовать переменную для удобства добавления игроков
Так как союзы задаются в основном при старте карты, то использовать эту переменную как глобальную, нет смысла и по этому создадим ее как локальную
Нажимаем на "Local Variables" и нажимаем Ctrl + W (это создать новый элемент)
Созданную переменную назовем "Player Group" и укажем ей тип "Группа игрока" (Рисунок 4)
Далее создадим действие "Add Player To Player Group" (Рисунок 5 и 6)
Где Player Group нажимаем и выбираем нашу переменную "Player Group" (Рисунок 7)
Таким образом, копируем наше получившееся действие сколько нам нужно(например 4 раза) и меняем игроков (Рисунок 8)
Создадим действие "Set alliance For Player Group" (Рисунок 9)
Где Player Group нажимаем и выбираем нашу переменную

Все готово.
Теперь игроки будут союзниками.

Естественно, если у вас 15 игроков и вам нужно чтобы они были союзниками, то вы можете использовать цикл, для добавления всех игроков в группу.</value>
            </setting>
            <setting name="Module1_Vopros1" serializeAs="String">
                <value>Пропала/не отображается панель редактирования поверхности, как исправить?</value>
            </setting>
            <setting name="Module1_Otvet1" serializeAs="String">
                <value>Представим такую картину, что вы впервые открылили редактор или случайно что-то нажали и у вас не отображается панель редактирования поверхности (Рисунок 1)
Все, что вам нужно сделать, так это нажать кнопку "Вид" на верхней панели и снова включить "Показать панель интерфейса" (Рисунок 2)

Готово.
Теперь вы снова можете редактировать поверхность. (Рисунок 3)</value>
            </setting>
            <setting name="Module1_Vopros2" serializeAs="String">
                <value>Не отоборажаются кноки редактирования поверхности, как исправить?</value>
            </setting>
            <setting name="Module1_Otvet2" serializeAs="String">
                <value>Представим такую картину, что вы впервые открылили редактор или случайно что-то сделали и у вас не отображаются кнопки редактирования поверхности (Рисунок 1)
Все, что вам нужно сделать, так это либо нажать на стрелки, либо навестись мышкой на одну из видимых кнопок и прокрутить колесико мыши вверх (Рисунок 2)

Готово.
Теперь вы снова можете редактировать поверхность. (Рисунок 3)</value>
            </setting>
            <setting name="Module3_Vopros6" serializeAs="String">
                <value>Как изменить цвет юнита?</value>
            </setting>
            <setting name="Module3_Vopros7" serializeAs="String">
                <value>Как изменить дальность оружия?</value>
            </setting>
            <setting name="Module3_Vopros8" serializeAs="String">
                <value>Как изменить скорость атаки оружия?</value>
            </setting>
            <setting name="Module3_Vopros9" serializeAs="String">
                <value>Как изменить урон оружия юнита?</value>
            </setting>
            <setting name="Module3_Otvet6" serializeAs="String">
                <value>Найдите юнита, которому вы хотите изменить цвет.
Откройте его Агент (Рисунок 1) и найдите поле "События+". (Рисунок 2)
Открыв события, нажмите ПКМ в любом свободном месте.
Из появившегося списка выберите "Добавить событие". (Рисунок 3)
Будет создано событие с прикрепленным к нему действием. (Рисунок 4)
Тип сообщения меняете на "Создание агента".
Далее выбираем действие и меняем его на "Задать оттенок".
В конце можно будет наглядно увидеть разницу между двумя юнитами.
Все параметры оставляете без изменений и указываете только нужный цвет и жмете ок.
После снова нажимаете ок и все готово. (Рисунок 8)
Рисунок 9 - Вид из редактора.
Рисунок 10 - Вид из игры.</value>
            </setting>
            <setting name="Module3_Otvet9" serializeAs="String">
                <value>Для того, что изменить урон оружия юнита, нужно для начала найти эффект урона, который наносит это оружие
Нажмите на оружие юнита и посмотрите, какой эффект указан в поле "Эффект" (Рисунок 1)
Так как у морпеха оружие не имеет снаряда, то у него в оружии сразу указан эффект урона (Рисунок 2)
Перейдя в этот эффект, найдите поле "Количество+"
У морпеха по умолчанию указано значение "6", это и есть урон его оружия
Вы можете менять это значение на любое другое

Вариант 2: Оружие со снарядом
Взяв в пример оружие мародера, видим что у него больше эффектов, связанных с его оружием (Рисунок 3)
Перейдя в его оружие, в поле эффекта, видим эффект запуска снаряда (Рисунок 5)
Теперь прейдем в эффект запуска снаряда, чтобы посмотреть с чем он еще связан (Рисунок 6)
Перейдем и в этот эффект и видим там эффект замедления и эффект насения урона (Рисунок 7)
Так мы последовательно выяснили какой именно эффект урона отвечает за его оружие
Это может быть полезно для юнитов, у которых несколько оружий или юнитов, которые используют оружие с несколькими уронами (Например, излучатель пустоты)</value>
            </setting>
            <setting name="Module3_Otvet8" serializeAs="String">
                <value>Для того, что изменить скорость атаки оружия юнита, нужно для начала перейти в его оружие
Нажмите на оружие юнита и найдите после "Интервал" (Рисунок 1)

У мародера по умолчанию 1.5 время между атаками
Вы можете менять это значение на любое другое

Готово.</value>
            </setting>
            <setting name="Module3_Otvet7" serializeAs="String">
                <value>Для того, что изменить дальность атаки оружия юнита, нужно для начала перейти в его оружие
Нажмите на оружие юнита и найдите после "Дальность" (Рисунок 1)

У мародера по умолчанию дальность 6
Вы можете менять это значение на любое другое

Готово.</value>
            </setting>
            <setting name="Module10_Vopros0" serializeAs="String">
                <value>Как сделать ботов по сложнее?</value>
            </setting>
            <setting name="Module10_Otvet0" serializeAs="String">
                <value>Чтобы изменить сложность ботов, зайдите для начала в настройки (Рисунок 1)
Перейдите во вкладку "Пробный запуск" и найдите "Сложность игры" (Рисунок 2)
Теперь вы можете изменить сложность ботов по умолчанию

Готово.</value>
            </setting>
            <setting name="Module2_Vopros6" serializeAs="String">
                <value>Как сделать смену дня и ночи?</value>
            </setting>
            <setting name="Module2_Otvet6" serializeAs="String">
                <value>Зайдите в Модуль триггеров и создайте новый триггер (Рисунок 1)
Создадим глобальную переменную, которая будет отвечать за День и Ночь 
Назовем ее "Day/Night", укажем тип "Булево" и начальное значение поменяем на "Истина"(Рисунок 2)
Определять будем так:
Истина - это день
Ложь - это ночь

Вернемя в триггер и создадим событие "Map initialization", которое будет выбрано по умолчанию сразу и сработает, как только карта загрузится (Рисунок 3)
Переходим сразу к действиям и создадим бесконечный цикл, который и будет запускать смену дня и ночи
Сделаем каркас для смены для и ночи, а потом сделаем отображения таймера

Создаем действие "Repeat Forever" (Рисунок 4)
В действиях этого цикла создадим "Wait" и укажем в него время, сколько будет идти день
В качестве примера укажу 30 секунд (Рисунок 5)
Так как у нас по умолчанию День и этот триггер сработает при старте карты, то ему нужно только ждать наступление ночи

После Wait создадим действие "Set Lighting" (Рисунок 6)
Где Light - укажем какое-нибудь освещение карты для ночи
Где Blend Time - время, в течении которого применится это освещение (Рисунок 7) (Со временем эксперементируйте)
Чтобы понять, какое освещение вам больше подходит, вы можете посмотреть их в отдельном окне "Освещение" (Рисунок 8, 9 и 10)
Так же можете посмотреть вопрос "Как сменить освещение карты?", чтобы более подробно об этом узнать

Теперь после "Set Lighting" создадим действие "Set Variable" (Рисунок 11)
Где Variable - Укажем нашу переменную (Рисунок 12)
Где Value - Откроем и просто нажмем "Ок", без установки галки на "Истина" (Рисунок 13)
Это мы сделали смену на ночь

Теперь сделаем смену на день
Скоприуем "Wait" и вставим его после "Set Value" (Рисунок 14)
Значение в этом ожидании, будет означать сколько длится ночь
Скоприуем так же "Set Light" и вставим его после "Wait" 
Как и в прошлый раз, изменим освещение на дневное (в моем случае это Argia) (Рисунок 15)
Скоприуем "Set Variable" и изменим заначение "Flalse" на "Истина" (Рисунок 16)

Каркас для смены дня и ночи готов.
Теперь можно прикрутить сюда таймер, для отображения длительности дня и ночи.

Создадим одну локальную переменную, назовем ее "Time of Day" и укажем тип "Таймер" (Рисунок 17)
Тут же, сразу создадим переменную, для отображения нашего таймера
Создаем еще одну локальную переменную, назовем ее "Timer Window" и укажем тип "Timer Window" (Рисунок 18)

Теперь в цикле, перед ожиданием для ночи, создадим действие "Start Timer" (Рисунок 19)
Где Timer - Открываем и указываем нашу переменную "Time of Day"
Где One Shot - Оставляем без изменений
Где Duration - Укажем сколько времени осталось до наступления ночи
В моем случае это 30 секунд

После создаем "Set Variable"
Где Variable - Укажем нашу переменную таймера "Time of Day" (Рисунок 20)
Где Value - Откроем, переключим на "функция" и укажем "Last Started Timer" (Рисунок 21)

Создадим следующее действие "Create Timer Window" (Рисунок 22)
Где Last Started Timer - Откроем, переключим на "Переменная" и укажем нашу переменную "Time of Day"
Где Title - Можете написать что-то вроде "День" (Рисунок 23)

Так же, после этого создадим действие "Set Variable"
Где Variable - Укажем нашу переменную "Timer Window"
Где Value - Откроем, переключим на "функция" и укажем "Last Created Timer Window" (Рисунок 24)

Теперь 4 действия, связанные с таймером скопируйте и вставьте после наступления ночи
То есть после "Set Variable" со значением "False" (Рисунок 25)
В "Create Timer Window" измените текст "День", на "Ночь"
В "Start Timer" измените время на то, сколько у вас длится ночь (Рисунок 26)

Уже в процессе добавления вопроса, заметил что забыл дописать одну строку, из-за которой у вас с каждым новым днем или ночью, будет создаваться новое окно с таймером
Это не правильно, он должен удалять старый и создавать новый
Вам нужно только добавить 2 действия "Destroy Timer Window" и указать туда переменную "Timer Window"
Разместить их перед действием "Create Timer Window"
Рисунок я добавил в самый конец (Рисунок 33)

Все готово.
Теперь у вас будет смена дня и ночи.

Такой способ очень простой и без лишних заморочек.
Если вы хотите привязать какие-то события на срабатывание таймера дня и ночи, то переменную "Time of Day" вам нужно будет просто перенести из локальных, в глобальные.
Потому что если переменная локальная, то вы не сможете получить к ней доступ из других триггеров.

Вот как перенести ее:
Скоруйте ее, нажмите на любой триггер или глобальную переменную и вставьте (Рисунок 27 и 28)
Вернитесь в триггер, нажмите на локальную версию этой переменной и нажмите "Delete" (Рисунок 29)
Он вам покажет что она задействована N кол-во раз
Нажимаем "Ок" и видим что везде, где она использовалась, подсвечивает красным (Рисунок 30)
Теперь просто вручную указываем нашу глобальную переменную (Рисунок 31 и 32)

Но с точки зрения удобства, это не очень правильно.
Вы можете использовать нажать на локальную переменную и нажать Ctrl + F10, чтобы посмотерть где она используется.
Так же, вы можете нажимать двойным кликом и переходить в конктреное место, к конкретному действию или функции, где используется переменная.
Это будет более правильно и более удобно.
На скришотах я показал вариант, когда триггер не большой и переменная почти нигде не используется.

Готово.
Теперь вы перенесли локальную переменная в глобальные и подставили ее везде, где она использовалась.
Так вы сможете использовать ее в других триггерах.</value>
            </setting>
        </SC2MapEdtiorXeX.Properties.Settings>
    </applicationSettings>
</configuration>