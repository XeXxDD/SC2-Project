<?xml version="1.0" encoding="utf-8" ?>
<configuration>
    <configSections>
        <sectionGroup name="applicationSettings" type="System.Configuration.ApplicationSettingsGroup, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" >
            <section name="SC2MapEdtiorXeX.Properties.Settings" type="System.Configuration.ClientSettingsSection, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" requirePermission="false" />
        </sectionGroup>
        <sectionGroup name="userSettings" type="System.Configuration.UserSettingsGroup, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" >
            <section name="SC2MapEdtiorXeX.Properties.Settings" type="System.Configuration.ClientSettingsSection, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" allowExeDefinition="MachineToLocalUser" requirePermission="false" />
        </sectionGroup>
    </configSections>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.6.1" />
    </startup>
    <applicationSettings>
        <SC2MapEdtiorXeX.Properties.Settings>
            <setting name="Module2_Otvet0" serializeAs="String">
                <value>Создаем новый триггер (Рисунок 1)
В нем создаем событие Chat Message (Рисунок 2)
Создав его, мы видим параметры, которое может принимать это событие (Рисунок 3)
Далее где Text: вписываете команду, на которую будет срабатывать триггер

Теперь создаем локальную переменную, называем ее Units (название может быть любым) и указываем ей тип "группа единиц" (Рисунок 4)
Создаем действие Set Varialbe (Рисунок 5)
Где Varible, указываем свою переменную Units (Рисунок 6)
Где Value, указываем: функция - Selected Units (Рисунок 7)
Где Player, указываем Triggering Player (Рисунок 8)

Далее создаем действие Pick Each Unit In Unit Group (Рисунок 9)
Где Unit Group, указываем нашу переменную Units (Рисунок 10)

Теперь тут же создаем действие If Then Else (Рисунок 11)
Где if создаем новый элемент(по умолчанию сравнение)(Ctrl + W) (Рисунок 12)
Где Value 1: Owner of Unit есть параметр Unit
В него указываем Picked Unit (Рисунок 13)
Где Value 2: Меняем на Triggering Player (Рисунок 14)
Далее в Then создаем действие Kill Unit (Рисунок 15)
Triggering Unit меняем на Picked Unit (Рисунок 16)

Готово.
Триггер на убийство юнитов при вводе команды чат готов.</value>
            </setting>
            <setting name="Module3_Vopros0" serializeAs="String">
                <value>Начало работы с модуем данных</value>
            </setting>
            <setting name="Module3_Vopros1" serializeAs="String">
                <value>Как сделать чтобы за убийство давались ресурсы?</value>
            </setting>
            <setting name="Module3_Otvet1" serializeAs="String">
                <value>Открыв вкладку "Единицы" найдите там юнита, за убийство которого будут даваться ресурсы.
Найдите поле "Уничтожить ресурс+" и открыв его, вы можете указать до 4х разных ресурсов.
Указывайте нужно количество и жмите ок.
Готово.</value>
            </setting>
            <setting name="Module3_Otvet0" serializeAs="String">
                <value>Для начала работы с модулем даныых, выставьте настройки таким образом (Рисунок 1)
Чтобы находить любые нужные данные, вы можете открывать и добавлять себе любые доступные вкладки (Рисунок 2)

Это нужно для того, чтобы при просмотре ответов на вопросы по модулю данных, у вас не возникали вопросы
Например, чтобы вы так же легко могли открыть агент любого юнита или любой другой объект, связанный с юнитом

Готово.</value>
            </setting>
            <setting name="Module2_Vopros0" serializeAs="String">
                <value>Как сделать убийство выбранного юнита при вводе команды в чат?</value>
            </setting>
            <setting name="Module2_Vopros1" serializeAs="String">
                <value>Какой ивент в триггерах делает что-бы после наступления определенного времени, происходило какое-нибудь действие?</value>
            </setting>
            <setting name="Module2_Otvet1" serializeAs="String">
                <value>За это отвечает событие "Time Elapsed" и "Periodic Event"
Находятся они по метке "Time" (Рисунок 1)

Вариант 1: Time Elapsed
Это событие отвечает за "Время прошло" и запускается один раз
Можно указывать время в секундах и тип времени (Рисунок 2)

Добавив вывод сообщения со временем миссии в чат, увидим такую картину (Рисунок 3)

Вариант 2: Periodic Event
Это событие отвечает за периодические события и запускается бесконечное кол-во раз
Так же можно указывать время в секундах и тип времени (Рисунок 4)

Добавив вывод сообщения со временем миссии в чат, увидим такую картину (Рисунок 5)

Готово.
Теперь вы знаете как это работает.</value>
            </setting>
            <setting name="Module2_Vopros2" serializeAs="String">
                <value>Как сделать подъем и спад лавы? + урон от лавы</value>
            </setting>
            <setting name="Module2_Otvet2" serializeAs="String">
                <value>Создадим простой рельеф для поднятия лавы (Рисунок 1)
Добавим лаву (Рисунок 2)
Откроем настройки воды (Рисунок 3)
Добавим новое состояние воды и сделаем цвет такой же как в "По умолчанию" 
Так же укажем нужну нам высоту для поднятой лавы. (Рисунок 4)
Зайдем в триггеры и создадим триггер, отвечающий за подъем и спад лавы. (Рисунок 5)
Создадим событие Pereodic Event и укажем время, через которое будет подниматься лава. (Рисунок 6)
Создадим устловие (If) (Рисунок 7)
Создадим глобальную переменную Lava Up/Down с типом "Булево" (Рисунок 8)
В условии будем проверять эту переменную со значением False (Рисунок 9)
В then создадим действие Play Sound и укажем туда звук TUIlavaRising (Рисунок 10)
Создадим действие Set Water State (Рисунок 11)
Где state укажем созданное ранее состояние воды (Рисунок 12)
Где over 1.0 secodns укажем 4 сек.
Далее создадим действие Wait для того, чтобы лава чисто визуально поднялась до нужного уровня,
ниже которого юниты будут получать урон. (Рисунок 13)
Далее создадим действие Turn Trigger On/Off
Где Off меняем на On
Current Trigger пока оставляем как есть (Рисунок 14)
После создадим действие Set Variable 
Где Variable укажем нашу переменную "Lava"
Где Value укажем "Истина" (Рисунок 15)

Теперь в Else скопируем действия:
Play Sound + Set Water State + Wait + Trigger On/Off + Set Variable (Рисунок 16)
Двух секундную задержку в действии Wait меняем на 1.5 сек.
В Set Variable "Истина" меняем на "Ложь", просто убрав галку(Рисунок 17)
В Set Water State меняем состояние на "По умолчанию" (Рисунок 18)
В Trigger On/Off параметр "On" меняем на "Off" (Рисунок 19)

Дальше нужно создать триггер, который будет наносить урон юнитам в лаве
Создадим триггер Lava Damage
Нажимаем на него ПКМ и убираем галку "Изначально включен" (Рисунок 20)
Добавим в него событие "Periodic Event" и установим параметр "Duration" на значение "0.5" (Рисунок 21)
Далее в условии триггера добавим условие(просто crtl + w + enter)
Где Value 1 укажем "Trigger Is On"
Где Value 2 укажем "Истина" (Рисунок 22)
Далее в действиях создаем "Pick Each Unit In Unit Group"(Рисунок 23)
Параметр Unit Group меняем на "Units In Unit group Matching Condition" (Рисунок 24)
Где Unit Filter открываем и двойным кликом меняем "Тип" "Воздушный" и "Неуязвимый" на "Исключено"
Так же снимаем галки "Союзник" и "Противник" (Рисунок 25)
Далее в Actions создаем проверку (If) (Рисунок 26)
Где If создадим устловие. В этом в условии:
Где Value 1 поменяем на Height At Point (Рисунок 27)
Где Unit меняем на Picked Unit (Рисунок 28)
Где Operator меняем на &lt;= (Меньше или равно)
Где Value 2 указываем значение, которое чуть меньше чем высота поднятой лавы. (Рисунок 29)
Это нужно для того, чтобы юниты получали урон зайдя в лаву, а не приблизившись к ней.
Далее в Then добавим действие Add Behavior (Player) (Рисунок 30)
Где Behavior укажем "Лава (урон)" (Рисунок 31)
Где Unit укажем Picked Unit (Рисунок 32)
Где Player укажем 15
Триггер на получение урона готов. (Рисунок 33)

Теперь нужно вернуться в триггер, который поднимает и опускает лаву.
В нем в обоих Trigger On/Off, где "Current Trigger" меняем на наш триггер получения урона.
(Рисунок 34)

Готово.</value>
            </setting>
            <setting name="Module3_Vopros2" serializeAs="String">
                <value>Как добавить на карту всех юнитов (протосов-подвиды талдаримы, неразимы и т.д и другие расы)?</value>
            </setting>
            <setting name="Module3_Otvet2" serializeAs="String">
                <value>При создании карты, указывайте карту игротеки или модификацию (Рисунок 1)
Вы можете нажать "стадрат", выбрать нужную кампанию и установить галку "данные кампании" (Рисунок 2)
Но со временем я выянил, что он не всегда включает все данные, всех трех кампаний и по этому сделаем по-другому
Нажимаем "По выбору" (Рисунок 3)
Нажимаем "Стандарт" и указываем галки всех трех кампаний + по желанию Nova (Рисунок 4)
Не указываем "Сетевой режим" вместе с ресурсами кампании, так как они будут конфликтовать
В итоге получится такой список (Рисунок 5)
Теперь нам доступны юниты из всех кампаний (Рисунок 6)</value>
            </setting>
            <setting name="Module2_Vopros3" serializeAs="String">
                <value>Как сделать ночную атаку зараженных?</value>
            </setting>
            <setting name="Module2_Otvet3" serializeAs="String">
                <value>Создадим простую карту, с несколькими юнитами (Рисунок 1)
Предположим, что у нас по умолчанию будет первый "День" и длиться он будет 15 сек.
После чего, наступит "Ночь" на 60 сек. и по ее завершии, наступит "День", который будет длиться 60 сек.
Далее они просто будут сменять друг-друга до бесконечности

В триггере "Инициализация схватки"(который создается по умолчанию), создадим действие "Start Campain AI For Player"(Рисунок 2)
Укажем туда не используемого игрока(Например 5)(Рисунок 3)
Создадим действие "Start Timer" (Рисунок 4)
Создадим глобальную переменную "Timer" с типом "Таймер" (Рисунок 5)
Вернемся в триггер "Инициализация схватки" и в действии "Start Timer", изменим:
Где Timer: (Нет значения) - поменяем на нашу переменную Timer (Рисунок 6)
Где Duration: 5.0 - поменяем на 15 (Рисунок 7)
Далее создадим действие Set Variable (Рисунок 8)
Теперь изменим:
Где Variable - Укажем нашу переменную Timer (Рисунок 9)
Где Value - Переходим в "Функция" и укажем Last Started Timer (Рисунок 10)
Далее создадим глобальную переменную "Timer Window" с типом "Timer Window" (Рисунок 11)
Вернемся в триггер "Инициализация схватки" и создадим действие "Create Timer Window" (Рисунок 12)
Теперь изменим:
Где Timer - Переходим в "переменная" и укажем нашу переменную "Timer" (Рисунок 13)
Где Title - Напишем "День" (Рисунок 14)
Далее снова создадим "Set Variable" и изменим:
Где Variable - Укажем нашу переменную "Timer Window"
Где Value - Переходим в "Функция" и укажем "Last Created Timer Window" (Рисунок 15)
На этом настройка первого триггреа завершена

Создадим новый триггер "Timer End", который будет отвечать за спавн зараженных и смену дня и ночи (Рисунок 16)
В событиях этого триггера создадим "Timer Expires" (Рисунок 17)
Где Timer - Укажем нашу переменную "Timer" (Рисунок 18)
Далее в действиях этого триггера создадим действие "Destroy Timer Window" (Рисунок 19)
Создадим действие проверки "If then else" (Рисунок 20)
Создадим глобальную переменную "Day/Night" с типом "Булево" (Рисунок 21)
Вернемся в триггер "Timer End" и в действии проверки изменим:
Где if - создадим сравнение (ctrl + w и просто нажмите enter) (Рисунок 22)
В этом сравнении:
Где Value 1 - Переходим в "переменная" и укажем нашу переменную "Day/Night" (Рисунок 23)
Где Value 2 - Переходим в "значение" и установим галку на "Истина" (Рисунок 24)
Теперь в действии проверки, в "Then" создадим действие "Set Variable" и изменим:
Где Variable - Укажем нашу переменную "Day/Night"
Где Value - Откроем и просто нажмем "Enter" не устанавливя галку на "Истина" (Рисунок 25)
Далее создадим действие "Set lighting" (Рисунок 26)
Где Light - Укажем "MeinhoffCampaignNight" (Рисунок 27)
Где Blend Time - Укажем 10 (Рисунок 28)
Далее создадим действие "Wait" и укажем туда 5 сек. (Рисунок 29)
Теперь вернемся в триггер "Инициализация схватки", скопируем от туда дейтвия:
1) Start Timer
2) Set Variable
3) Create Timer Window
4) Set Variable (Рисунок 30 - выделены синим)
Теперь вернемся в триггер "Timer End" и вставим их после действия "Wait" (Рисунок 31)
В действии "Start Timer", 15 сек. изменим на 60 сек. (Столько будет длиться ночь)
В действии "Create Timer Window", текст "День" изменим на "Ночь" (Рисунок 32)
Теперь нужно скопировать все действия в "Then" и вставить их в "Else" (Рисунок 33)
В действии "Set Variable" со значением "Day/Night == False", где "False" нужно изменить на "Истина" (Рисунок 34)
В действии "Create Timer Window", текст "Ночь" изменим на "День" (Рисунок 35)
Почти готово. Теперь нужно создать спавн и уничтожение зараженных.

Создадим глобальную переменную "Infested Terrans" с типом "Группа единиц" (Рисунок 36)
Создадим "Определение действия"(или кастомное действие как я говорю), которое можно создать так:
1) Нажав Ctrl + Alt + R
2) Нажав ПКМ в пустом месте триггров и выбрав соответствующий пункт (Рисунок 37)
3) Нажав кнопку на верхней панели (Рисунок 38)
Назвоем его например "Random Infested Terran" (Оно будет отвечать за спавн зараженных)
В нем сразу переходим к действиям и создадим действие "While" (Рисунок 39)
В условии создадим сравнение и изменим:
Где Value 1 - Укажем нашу переменную "Day/Night"
Где Value 2 - Откроем и просто нажмем "Enter" не устанавливя галку на "Истина" (Рисунок 40)
Далее в "Then" создадим действие "Switch", которое будет спанвить одого из двух видов зараженных
Но вы так же сможете расширить список и добавить нужных вам юнитов (Рисунок 41)
Теперь в "Cases" нажмем Ctrl + W дважы (Рисунок 42)
Теперь вне "Cases", где Value открываем, переключаем на "функция" и указываем там "Random Integer" (Рисунок 43)
Где Min - Укажем единицу
Где Max - Укажем двойку (Рисунок 44)
Теперь где if (Value) - укажем 1 и 2 (Рисунок 45)
Далее где if(1) - Создадим действие "Create Units Facing Angle" (Рисунок 46)
В действии "Create Units Facing Angle" изменим:
Где Type: (не значения) - Укажем закопанного зараженного террана (Рисунок 47)
Где Player - Укажем не используемого игрока, которого мы указывали в триггере "Инициализация схватки"
Где Point: (нет значения) - Переходим в "Функция", выбираем вкладку "Region" и выбираем "Random Point In Region" (Рисунок 48)
Где Region - Переходим в "функция" и выбираем "Playable Map Area" (Рисунок 49)
Получившееся действие копируем в if(2) и меняем юнита на "Зараженного морпеха" (Рисунок 50)
Далее вне "Switch" создадим действие "Enable/Disable Suicide For Unit" (Рисунок 51)
После создадим "Wait" со значением 2 сек. чтобы юниты не заспамили сразу всю карту и игра зависла

Теперь вернемся в триггер "Timer End" и в "Then", в самом конце, после "Set Variable" создадим наше новое действие
"Random Infested Terran" (Рисунок 52)
Теперь при наступлении ночи, будут спавниться, выкапываться и идти в атаку зараженные

Осталось создать уничтожение зараженных при наступлении дня
Создадим новое "Определение действия" и назовем его "Die Infested Terran"
В действиях создадим "Pick Each Unit In Unit Group" (Рисунок 53)
В нем создадим действие "Add Behavior" (Рисунок 54)
У него изменим:
Где Behavior - Укажем Солнечное возгорание
Где Unit и Caster- Переходим в "функция" и укажем "Picked Unit" (Рисунок 55)
Далее создадим действие "Remove Unit From Unit Group" и изменим у него:
Где Unit - Переходим в "функция" и укажем "Picked Unit"
Где Unit Group - Укажем нашу переменную "Infested Terrans" (Рисунок 56)
Теперь вернемся в триггер "Timer End", в "Else", в самом конце создадим наше новое действие "Die Infested Terran" (Рисунок 57)
Все готово.

Теперь поясню один баг, который я обнаружил во время тестов:
Милишные зараженные не всегда выкапыются и не идут таковать, хотя у них включен суицид.
Я придумал решение этой проблемы, усложнением их спавна. 
Вы можете этого не делать и оставить как есть, если у вас много разных зараженных будет.

В "Определении действия Random Infested Terran" после "Wait" создаем проверку "If Then Else"
Где if - Создадим сравнение и изменим у него:
Где Value 1 - Переходим в "функция" и укажем "Unit type of unit" (Рисунок 58)
Где Unit - Меняем на "Last Created Unit"
Где Value 2 - Укажем зараженного террана (Рисунок 59)
Теперь "Wait" и суицид для юнита переносим в "Else", меняя их местами так, чтобы задежка была после включения суецида(Рисунок 60)
Далее в "Then" создадим "Wait" со значением "0.5"
После него создадим "Issue Order" (Рисунок 61)
Где Unit - Меняем на "Last Created Unit"
Где Ability Command - Меняем на "Infested Terran - Выкопаться" (Рисунок 62)
Копируем "Wait" со значением "0.5" и вставляем его после "Issue Order"
Копируем "Issue Order" и вставляем после второго "Wait" (Рисунок 63)
Где Order - Меняем на "Order Targeting Point" (Рисунок 64)
Где Ability Command - Меняем на "Атаковать" (Рисунок 65)
Где Target Point - Меняем на "функция" и указываем "Position Of Unit" (Рисунок 66)
Где Unit в Target Point пока оставляем без изменений

Теперь нужно определиться, если у вас на карте больше одного игрока, на которого могут нападать зараженные, то нужно создать функцию,
которая будет возвращать нам случайного юнита одного из игроков.
Но для начала, я покажу что делаем если игрок всего один.
Где Unit в Target Point - Меняем на "Random Unit From Unit Group" (Рисунок 67)
Где Group - Меняем на "Units In Region Matching Condition" (Рисунок 68)
Где Unit Filter - Открываем и двойным кликом меняем "Передмет" и "Неуязвимый" на значение "Исключено" (Рисунок 69)
Где Player - Укажем игрока, на которого должны нападать зараженные. Например это будет игрок 1 (Рисунок 70)
Готово. Теперь если игрок для нападения один, то все будет работать.

Теперь рассмотрим вариант, где игроков несколько.
Создадим "Функцию" точно так же, как мы создавали "Определение действия", и назовем ее "Random Unit Player" (Рисунок 71)
Далее где "Return Type" изменим на "Единица"
Теперь спускаемся в локальные переменные и создадим переменную "Units" с типом "Группа единиц" (Рисунок 72)
Теперь в действиях создадим "Pick Each Integer", который будет отвечать за поиск игрока, единицы которого нужно атаковать. (Рисунок 73)
Прежде чем его менять, нужно создать "Параметр" с типом "Целое число" и назовем его "Player" (Рисунок 74)
В Pick Each Integer нужно изменить:
Где Start - Без изменений
Где End - Укажем созданный нами параметр "Player" (Рисунок 75)
Теперь нужно в нем создать действие "Pick Each Unit In Unit Group" (Рисунок 76)
В нем нужно изменить:
Где Unit Group - Меняем на "Units In Region Matching Condition" (как на рисунке 68)
Где Region - указываем "Playable Map Area" (В предыдуще способе на рисунке 68 я забыл об этом написать)
Где Player - меняем на "Параметр" и указываем наш параметр "Player"
Где Unit Filter - Открываем и двойным кликом меняем "Передмет" и "Неуязвимый" на значение "Исключено" (как на рисуноке 69)
Это действие почти готово (Рисунок 77)
Теперь в "Pick Each Unit In Unit Group" создадим действие "Add Unit To Unit Group" (Рисунок 78)
Где Unit - Меняем на "Picked Unit"
Где Unit Group - Меняем на нашу переменную "Units" (Рисунок 79)
И последнее дейтвие "Return"
В нем указываем "Random Unit From Unit Group" и где "Group" указываем нашу переменную "Units" (Рисунок 80)

Теперь вернемся в наше кастомное действие "Random Infested Terran" и найдем второе действие по отдачае приказа (Рисунок 81)
В нем изменим:
Где Unit в Target Point - меняем на созданную нами функцию "Random Unit Player" (Рисунок 82 и 83)
И последнее:
Где Player - указываем номер конечного игрока, на которого должны нападать зараженные
Например, так как счет в функции начинается с единицы, а у вас 4 игрока, то указываем 4 (Рисунок 84)

Все готово.
Теперь не будет случаев, когда какой-то зараженный не выкопался, или выкопался, но не пошел атаковать.</value>
            </setting>
            <setting name="Module3_Vopros3" serializeAs="String">
                <value>Как сделать так что-бы за каждый выстрел (например морпеха) тратилась 1 единица энергии?</value>
            </setting>
            <setting name="Module3_Otvet3" serializeAs="String">
                <value>В данных, во вкладке "Единицы", найдите юнита, которому вы хотите сделать атаку за энергию(Рисунок 1)
Измените ему поле "Начальный запас энергии" и "Максимальное кол-во энергии" на нужное вам заначение(например 10) (Рисунок 2 и 3)
Проверье, чтобы "Скорость восстановления энергии была равна нулю" (Рисунок 3)
Далее во вкладке "Оружие", или перейдя прямо к нему из связанных объектов с единицей, найдите оружие вашего юнита (Рисунок 4)
Найдите у него поле "Стоимость +" (Рисунок 5)
Где "Основные показатели ^", измените "Энергия" на требуемое значение для каждой атаки(например 1) (Рисунок 6)
Нажмите ОК

Все готово, теперь при атаке юнит будет расходовать собственную энергию, а когда она закончится, он не сможет атаковать.
</value>
            </setting>
            <setting name="Module3_Vopros4" serializeAs="String">
                <value>Как поменять размер юнита?</value>
            </setting>
            <setting name="Module3_Otvet4" serializeAs="String">
                <value>В данных найдите своего юнита, которому хотите изменить размер (Рисунок 1)

Способ 1:
У него найдите агент(Рисунок 2) и свойство "Шкала" (Рисунок 3)
Чтобы понять как вам указать нужный размер, нужно понять как в ск2 выглядят проценты
1 - это означает 100%
0.1 - это означает 10%
0.01 - это означает 1%
Что касается размера юнита, то по умолчанию 100%, и если вы хотите изменить размер, то нужно указывать число после единицы или вместо единицы
Например:
2 - увеличение размера на 100%
1.1 - увеличение размера на 10%
1.01 - увеличение размера на 1%

Изменим размер на 100% (Рисунок 4)
Теперь морпех увеличился в 2 раза (Рисунок 5)

Способ 2:
У вашего юнита найдите основную модель (Рисунок 6)
Там найдите и измените поле "Минимальный масштаб" и "Максимальный масштаб" (Рисунок 7 и 8)
Готово.</value>
            </setting>
            <setting name="Module3_Vopros5" serializeAs="String">
                <value>Как сменить модель юнита?</value>
            </setting>
            <setting name="Module3_Otvet5" serializeAs="String">
                <value>Разместим на карте юнита, которому хотим изменить модель (Рисунок 1)

В данных найдем этого юнита (Рисунок 2)
Вариант 1:
У него откроем агент (Рисунок 3)
Найдем поля: Модель, Модель (постройка) и Модель (размещение) (Рисунок 4)
Таким способом вы можете изменить текущую модель на другую, со всеми настройками
Но для этого нужно понимать, какую именно модель нужно выбирать
Если вам нужна модель юнита, то чаще всего они будут иметь название без лишних частей
Например: Marine, Medivac, Mothership и тд.
Так же, в списке сортировки, вы можете указать тип "Unit" (Рисунок 5)
Но минус такого способа в том, что близзард наделали кучу типов, с конкетным названием юнита и вы можете не найти основную модель нужного юнита
Пример можно увидеть на Рисунке 6 и Рисунке 7

Укажем модель пилона(Рисунок 8) и укажем их в оставшиеся 2 поля(Рисунок 9)
Вы можете нажать Ctrl + C на первое поле и Ctrl + V на оставшиеся 2 поля
Теперь морпех у нас выглядит как пилон(Рисунок 10 и Рисунок 11)

Вариант 2:
Найдите у вашего юнита основную модель (Рисунок 12)
Найдите у нее поле "Модель" (Рисунок 13)
Открыв его, нажмите "Обзор" (Рисунок 14)
В списке найдите нужную модель (Рисунок 15)
Я указал в качестве примера модель крейсера (Рисунок 16)
Теперь морпех выглядит как крейсер (Рисунок 17 и Рисунок 18)</value>
            </setting>
            <setting name="Module1_Vopros0" serializeAs="String">
                <value>Все юниты вдруг начали летать, как это изменить?</value>
            </setting>
            <setting name="Module2_Vopros4" serializeAs="String">
                <value>Как сменить скины юнитов?</value>
            </setting>
            <setting name="Module2_Otvet4" serializeAs="String">
                <value>Смена скинов происходит через действия триггеров

Для начала разместим несколько юнитов, для того, чтобы посмотреть что это работает (Рисунок 1)
Далее заходим в модуль Триггеров и выбираем созданный по умолчанию триггер "Инициализация схватки"
У него в действиях нужно создать "Apply Player Skin" (Рисунок 2)
Там есть просто "Apply Player Skin" и "Apply Player Skin (Peplacing Existing Unit)"
Apply Player Skin - применяет скин, но не заменяет модели у уже созданных на карте юнитов
Apply Player Skin (Peplacing Existing Unit) - делает тоже самое, только заменяет модели у уже созданных на карте юнитов

Создадим оба этих действия для наглядности (Рисунок 3)
Теперь выбираем любое из этих действий и где "No Game Link", мы можем указать конкетный скин 
(Рисунок 4)
Но проблема в том, что они все называются одинаково и если вам нужен один конкетный скин, его будет найти очень сложно
Например, на этой тестовой карте, я хочу использовать только гидралисков и гиблингов 
Чтобы их найти, придется буквально все скины перебирать по одному, чтобы найти нужный

Чтобы этого не делать, мы зайдем в модуль Данных и откроем там вкладку "Облики" из раздела "Герой" (Рисунок 5)
Теперь мы видим все доступные скины (Рисунок 6)
Далее мы просто нажимаем на любой из них и в свойтсвах ищем поле "Отобразить модель+"
В этом после написано имя юнита, которому будет заменена модель
Если вы все еще не можете понять что это за юнит, вы можете открыть поле "Значок вариаций" 
(Рисунок 8 и 9)

Теперь, чтобы нам упростить себе жизнь, мы можем добавать "Префикс редактора" или "Суффикс редактора"
Это нужно для того, чтобы в триггерах проще было найти нужный скин
Например, я добавлю "Префикс" на скин для гиблингов и гидралисков
(Префикс и Суффикс - это тоже свойсва, как и "Отобразить модель+")

Далее вернувшись в триггеры, я могу при помощи поиска легко найти нужные мне скины (Рисунок 10)
Установлю скины таким образом:
Apply Player Skin - Выберу там гиблингов
Apply Player Skin (Peplacing Existing Unit) - Выберу там гидралисков (Рисунок 11)

Запустив игру, мы можем видеть что у гиблингов скин не поменялся, а у гидралисков поменялся (Рисунок 12)
Это связно с тем, что гиблинги сразу есть на карте и скины будут применены только к новым, созданным юнитам (Рисунок 13)

Таким образом, мы выяснили что нужно использовать "Apply Player Skin (Peplacing Existing Unit)"
Так же, при смене скинов, нунжо указывать игрока(по умолчанию 1)
Если у вас на карте 10 игроков, то скины нужно применять для всех
Еще если вы хотите все скины, то их так же, все нужно указывать при помощи действий триггеров (Рисунок 14)
На скриншоте я указал не все, так как это просто пример

Теперь вариант, как можно все эти скины, применить ко всем 10-ти игрокам
Вы можете создать цикл, который сделает все за вас
Создадим "Pick Each Integer"(Рисунок 15) и поместим наши действия на смену скинов, в этот цикл (Рисунок 16)
Начало и конец цикла можно менять (Рисунок 17)
Теперь в наших действиях по смене скинов, где "Player 1", открываем, меняем на "Фукнкция" и указываем "Picked Integer" (Рисунок 18)
Теперь вы можете просто скопировать этот параметр для остальных действий (Рисунок 19 и 20)

Все готово.
Теперь вы знаете как менять скины и где их найти.</value>
            </setting>
            <setting name="Module11_Vopros0" serializeAs="String">
                <value>Как скачать и редактировать карту из игротеки?</value>
            </setting>
            <setting name="Module11_Otvet0" serializeAs="String">
                <value>Чтобы открыть карту опубликованные карты, нужно для начала нажать кнопку открытия карты (Рисунок 1)
Потом нужно переключиться на вкладку "Blizzard" и авторизоваться (Рисунок 2)
Там можно еще выбрать регион, но в теории, он сам его определит при авторизации
Если этого не произошло, попробуйте указать его вручную

Теперь вы можете указать "Источник" (Рисунок 3)
Выбрав один из источников, найдите в списке нужную карту, нажмите "Загрузить" и нажмите "ОК" (Рисунок 4)

Все готово, вы открыли опубликованную карту и можете ее редактировать.
При открытии опубликованных карт, есть нюанс, а именно: вы не можете открыть и редактировать "Закрытые карты"
Если нужная вам карта не находится по названию и последним сыгранным играм, возможно она закрыта для редактирования.
При публикации карты, каждый автор указывает, можно или нельзя ли будет редактировать его карту.
Так же, если вы являетесь автором этой карты и утратили исходники, то скорее всего тут ничего не поделать, так как даже собственные карты нельзя открывать таким способом.

Если вы хотите скачать какую-то свою карту, то можете использовать "Управление опубликованными материалами" (Рисунок 5)
Что представляет из себя почти тоже самое, только отображает карты, опубликованные вами.</value>
            </setting>
            <setting name="Module2_Vopros5" serializeAs="String">
                <value>Как сделать другого игрока союзником?</value>
            </setting>
            <setting name="Module2_Otvet5" serializeAs="String">
                <value>Зайдем в модуль Триггеров и откроем созданный по умолчанию триггер "Инициализация схватки"

Вариант 1: Самый простой
В действиях этого триггера, создадим "Set Allliance" (Рисунок 1)
Это действие позволяет задать союз между двумя игроками (Рисунок 2)
Где Source Player и Target Player можете указывать двух игроков, которые должны быть в союзе
Так же вы можете выбрать варианты союзов:
1) Просто союзники (без общего обзора)
2) Союзники с общим обзором
3) Союзники с общим обзором и контролем
4) Союзники с общим обзором и чем-то еще (не проверял)
5) Союзники с общим обзором, контролем и припасами/ресурсами(не точно)
6) Враги
7) Враги с общим обзором
8) Нейтралы
9) Нейтралы с общим обзором
10) Нейтралы с общим обзором и чем-то еще (не проверял)
(Рисунок 3)

Если на карте много игроков, такой способ будет не очень удобен, так как каждый игрок должен быть в союзе со всеми остальными игроками
Вам придется много раз копировать это действие и вручную указывать союзы для каждого игрока

Вариант 2: Сложнее, но удобнее
Будем использовать переменную для удобства добавления игроков
Так как союзы задаются в основном при старте карты, то использовать эту переменную как глобальную, нет смысла и по этому создадим ее как локальную
Нажимаем на "Local Variables" и нажимаем Ctrl + W (это создать новый элемент)
Созданную переменную назовем "Player Group" и укажем ей тип "Группа игрока" (Рисунок 4)
Далее создадим действие "Add Player To Player Group" (Рисунок 5 и 6)
Где Player Group нажимаем и выбираем нашу переменную "Player Group" (Рисунок 7)
Таким образом, копируем наше получившееся действие сколько нам нужно(например 4 раза) и меняем игроков (Рисунок 8)
Создадим действие "Set alliance For Player Group" (Рисунок 9)
Где Player Group нажимаем и выбираем нашу переменную

Все готово.
Теперь игроки будут союзниками.

Естественно, если у вас 15 игроков и вам нужно чтобы они были союзниками, то вы можете использовать цикл, для добавления всех игроков в группу.</value>
            </setting>
            <setting name="Module1_Vopros1" serializeAs="String">
                <value>Пропала/не отображается панель редактирования поверхности, как исправить?</value>
            </setting>
            <setting name="Module1_Otvet1" serializeAs="String">
                <value>Представим такую картину, что вы впервые открылили редактор или случайно что-то нажали и у вас не отображается панель редактирования поверхности (Рисунок 1)
Все, что вам нужно сделать, так это нажать кнопку "Вид" на верхней панели и снова включить "Показать панель интерфейса" (Рисунок 2)

Готово.
Теперь вы снова можете редактировать поверхность. (Рисунок 3)</value>
            </setting>
            <setting name="Module1_Vopros2" serializeAs="String">
                <value>Не отоборажаются кноки редактирования поверхности, как исправить?</value>
            </setting>
            <setting name="Module1_Otvet2" serializeAs="String">
                <value>Представим такую картину, что вы впервые открылили редактор или случайно что-то сделали и у вас не отображаются кнопки редактирования поверхности (Рисунок 1)
Все, что вам нужно сделать, так это либо нажать на стрелки, либо навестись мышкой на одну из видимых кнопок и прокрутить колесико мыши вверх (Рисунок 2)

Готово.
Теперь вы снова можете редактировать поверхность. (Рисунок 3)</value>
            </setting>
            <setting name="Module3_Vopros7" serializeAs="String">
                <value>Как изменить дальность оружия?</value>
            </setting>
            <setting name="Module3_Vopros8" serializeAs="String">
                <value>Как изменить скорость атаки оружия?</value>
            </setting>
            <setting name="Module3_Vopros9" serializeAs="String">
                <value>Как изменить урон оружия юнита?</value>
            </setting>
            <setting name="Module3_Otvet6" serializeAs="String">
                <value>Найдите юнита, которому вы хотите изменить цвет.
Откройте его Агент (Рисунок 1) и найдите поле "События+". (Рисунок 2)
Открыв события, нажмите ПКМ в любом свободном месте.
Из появившегося списка выберите "Добавить событие". (Рисунок 3)
Будет создано событие с прикрепленным к нему действием. (Рисунок 4)
Тип сообщения меняете на "Создание агента".
Далее выбираем действие и меняем его на "Задать оттенок".
В конце можно будет наглядно увидеть разницу между двумя юнитами.
Все параметры оставляете без изменений и указываете только нужный цвет и жмете ок.
После снова нажимаете ок и все готово. (Рисунок 8)
Рисунок 9 - Вид из редактора.
Рисунок 10 - Вид из игры.</value>
            </setting>
            <setting name="Module3_Otvet9" serializeAs="String">
                <value>Для того, что изменить урон оружия юнита, нужно для начала найти эффект урона, который наносит это оружие
Нажмите на оружие юнита и посмотрите, какой эффект указан в поле "Эффект" (Рисунок 1)
Так как у морпеха оружие не имеет снаряда, то у него в оружии сразу указан эффект урона (Рисунок 2)
Перейдя в этот эффект, найдите поле "Количество+"
У морпеха по умолчанию указано значение "6", это и есть урон его оружия
Вы можете менять это значение на любое другое

Вариант 2: Оружие со снарядом
Взяв в пример оружие мародера, видим что у него больше эффектов, связанных с его оружием (Рисунок 3)
Перейдя в его оружие, в поле эффекта, видим эффект запуска снаряда (Рисунок 5)
Теперь прейдем в эффект запуска снаряда, чтобы посмотреть с чем он еще связан (Рисунок 6)
Перейдем и в этот эффект и видим там эффект замедления и эффект насения урона (Рисунок 7)
Так мы последовательно выяснили какой именно эффект урона отвечает за его оружие
Это может быть полезно для юнитов, у которых несколько оружий или юнитов, которые используют оружие с несколькими уронами (Например, излучатель пустоты)</value>
            </setting>
            <setting name="Module3_Otvet8" serializeAs="String">
                <value>Для того, что изменить скорость атаки оружия юнита, нужно для начала перейти в его оружие
Нажмите на оружие юнита и найдите после "Интервал" (Рисунок 1)

У мародера по умолчанию 1.5 время между атаками
Вы можете менять это значение на любое другое

Готово.</value>
            </setting>
            <setting name="Module3_Otvet7" serializeAs="String">
                <value>Для того, что изменить дальность атаки оружия юнита, нужно для начала перейти в его оружие
Нажмите на оружие юнита и найдите после "Дальность" (Рисунок 1)

У мародера по умолчанию дальность 6
Вы можете менять это значение на любое другое

Готово.</value>
            </setting>
        </SC2MapEdtiorXeX.Properties.Settings>
    </applicationSettings>
    <userSettings>
        <SC2MapEdtiorXeX.Properties.Settings>
            <setting name="Module1_Otvet0" serializeAs="String">
                <value>Все юниты вдруг начали летать, как это изменить?

За это отвечает поле высот. Если оно настроенно не правильно, юниты будут "летать"
Я создал простую поверхность, чтобы показать как это работает (Рисунок 1-3)
Как видим, все нормально, юниты не "летают", а стоят на земле
Но если мы подведем морпеха в яму, то увидим что он стоит "на воздухе" (Рисунок 4)
По умолчанию базовая высота равна 8 единицам (Рисунок 5)
Посмотреть и изменить это значение можно в настройках карты (Рисунок 6)
Так же, чтобы понять какая именно высота вам нужна, нужно включить ее отображение на поверхности (Рисунок 7)
Теперь на повехности видим оранжевые полости, показывающие нам ниже какой высоты не может опуститься юнит (Рисунок 8)
Это можно изменить, просто убрав галку "Базовая высота для всех боевых единиц" (Рисунок 9)
Теперь юниты смогут спускаться в ямы, а не ходить "по воздуху"

Но это не решает проблему того, что юниты вдруг начали "летать"
Чтобы это исправить, нужно проверить чтобы базовая высота была равна 8 единицам, как это должно быть по умолчанию
Возможно, конкретно для вашей карты нужно будет другое значение и тут только эксперементировать
Перед тем, как изменять высоту, сохраните копию карты, так как измение высоты может привести к необратимому выравниванию поверхности

Теперь рассмотрим вариант по теме вопроса:
Изменим высоту например на 10 единиц и видим, что над поверхностью имеется оранжевый квадрат по всей карте
Теперь это минимальная высота для юнитов и это приводит к тому, что они летают (Рисунок 10)
Запустив игру, мы можем наблюдать следующую картину (Рисунок 11)
Все юниты, включая даже минералы, находятся "в воздухе"
Исправляем это изменением высоты до значения по умолчанию(то есть 8 единиц)

Готово.
Теперь вы знаете как работает поле высот и возможно решили свою проблему с "летающими" юнитами.</value>
            </setting>
            <setting name="Module3_Vopros6" serializeAs="String">
                <value>Как изменить цвет юнита?</value>
            </setting>
        </SC2MapEdtiorXeX.Properties.Settings>
    </userSettings>
</configuration>